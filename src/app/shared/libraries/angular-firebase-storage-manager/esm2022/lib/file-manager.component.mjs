import { Component, Input } from '@angular/core';
import { NewFolderDialogComponent, } from './components/new-folder-dialog/new-folder-dialog.component';
import { SelectionModel } from '@angular/cdk/collections';
import { DeleteFilesDialogComponent, } from './components/delete-files-dialog/delete-files-dialog.component';
import { AsyncPipe, DatePipe, NgClass } from '@angular/common';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTableModule } from '@angular/material/table';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { StorageItemIconComponent, } from './components/storage-item-icon/storage-item-icon.component';
import { FormatBytesPipe } from './pipes/format-bytes.pipe';
import { StorageFilePreviewComponent, } from './components/storage-file-preview/storage-file-preview.component';
import { FileDropzoneDirective } from './directives/file-dropzone.directive';
import { LoadingOrErrorComponent, } from './components/loading-or-error/loading-or-error.component';
import { first } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/dialog";
import * as i2 from "./services/console-logger.service";
import * as i3 from "./services/firebase-storage.service";
import * as i4 from "@angular/material/button";
import * as i5 from "@angular/material/icon";
import * as i6 from "@angular/material/table";
import * as i7 from "@angular/material/checkbox";
export class FileManagerComponent {
    constructor(dialog, cLog, storageService) {
        this.dialog = dialog;
        this.cLog = cLog;
        this.storageService = storageService;
        /**
         * The columns to display in the file management table.
         */
        this.tableColumns = ['checkbox', 'name', 'size', 'type', 'lastModified'];
        /**
         * The current path within the storage system.
         */
        this.currentPath = '';
        /**
         * Used for managing multiple item selection within the file manager.
         */
        this.selection = new SelectionModel(true, []);
        /**
         * The root path within the storage system where the file manager operates.
         */
        this.rootStoragePath = '';
    }
    ngOnInit() {
        /** Sets the initial path within the storage system */
        this.currentPath = this.rootStoragePath;
        /** Fetches the initial storage items */
        this.items$ = this.getAllStorageItems(this.currentPath);
    }
    /**
     * Downloads the provided files by triggering download links.
     * @param {StorageItem[]} files - The files to download.
     */
    async downloadFiles(files) {
        await this.storageService.openAllFiles(files);
    }
    /**
     * Toggles the selection of all items in the file listing.
     *
     * @param {boolean} checked - Whether to select or deselect all items.
     * @param {StorageItem[]} items - The list of file items.
     */
    toggleAllItems(checked, items) {
        if (!checked) {
            this.selection.clear();
            return;
        }
        this.selection.select(...items);
    }
    /**
     * Checks if all items in the file listing are currently selected.
     *
     * @param {StorageItem[]} items - The list of file items.
     * @return {boolean} True if all items are selected, false otherwise.
     */
    allItemsSelected(items) {
        return this.selection.selected.length === items.length &&
            this.selection.selected.length > 0;
    }
    /**
     * Checks if some, but not all, items in the file listing are selected.
     *
     * @param {StorageItem[]} items - The list of file items.
     * @return {boolean} True if the selection state is indeterminate, false
     * otherwise.
     */
    allItemsIndeterminate(items) {
        return this.selection.selected.length > 0 &&
            this.selection.selected.length < items.length;
    }
    /**
     * Event handler for when a storage item is selected. Updates the navigation
     * if a folder is selected, or sets the selected file if a file is selected.
     *
     * @param {StorageItem} item - The selected StorageItem.
     */
    storageItemSelected(item) {
        if (item.type === 'folder')
            this.setStoragePath(item.fullPath);
        else if (item.type === 'file')
            this.selectedFile = item;
    }
    /**
     * Checks if the current selection includes at least one folder.
     *
     * @return {boolean} True if a folder is part of the selection, false
     * otherwise.
     */
    get selectionIncludesFolder() {
        return this.selection.selected.some((item) => item.type === 'folder');
    }
    /**
     * Opens a dialog to confirm deletion, and handles deleting selected items
     * if confirmed. Clears the selection and updates the file listing.
     *
     * @param {StorageItem[]} items - The items to delete.
     */
    deleteItems(items) {
        const dialogRef = this.dialog.open(DeleteFilesDialogComponent, {
            id: 'delete-files-dialog',
            minWidth: '250px',
        });
        dialogRef.afterClosed().pipe(first()).forEach((confirm) => {
            if (confirm) {
                this.storageService.deleteFiles(items)
                    .then(() => {
                    this.selection.clear();
                    if (items.some((item) => item == this.selectedFile)) {
                        this.selectedFile = undefined;
                    }
                })
                    .then(() => this.reload(this.currentPath));
            }
        });
    }
    /**
     * Constructs a breadcrumb-style path string based on the current path
     * history. Used for navigation display.
     *
     * @param {string[]} pathArray - An array of path segments.
     * @param {number} index - The index up to which path segments should be
     * included.
     * @return {string} The constructed path string.
     */
    getCrumbPath(pathArray, index) {
        pathArray.length = index + 1;
        return pathArray.join('/');
    }
    /**
     * Updates the current path and fetches the new file listing.
     * Clears any existing selection.
     *
     * @param {string} path - The new storage path.
     */
    setStoragePath(path) {
        this.items$ = this.getAllStorageItems(path);
        this.currentPath = path;
        if (this.selection.hasValue())
            this.selection.clear();
    }
    /**
     * Retrieves and processes all items within a given storage path.
     *
     * @param {string} path - The storage path to list.
     * @return {Promise<StorageItem[]>} A Promise resolving to the items,
     * or undefined in case of error.
     */
    async getAllStorageItems(path) {
        const storageRef = this.storageService.getRef(path);
        return this.storageService.listAll(storageRef)
            .then(async ({ items, prefixes }) => {
            const allItems = [
                ...prefixes.map(this.storageService.importFolder),
                ...(await Promise.all(items.map(this.storageService.importFile))),
            ];
            return allItems;
        })
            .catch((error) => {
            this.error = error;
            return new Promise(() => undefined);
        });
    }
    /**
     * Reloads the file and folder listing within the current or specified path.
     *
     * @param {string | null} path - Optional. The path to reload. If null,
     * the current path is used.
     */
    reload(path = null) {
        let pathRef;
        if (path)
            pathRef = this.storageService.getRef(path);
        else
            pathRef = this.storageService.getRef(this.currentPath);
        this.items$ = this.storageService.listAll(pathRef)
            .then(async ({ items, prefixes }) => [
            ...prefixes.map(this.storageService.importFolder),
            ...(await Promise.all(items.map(this.storageService.importFile))),
        ]);
    }
    /**
     * Opens a dialog to create a new folder and updates folder listing
     * if successful.
     */
    createNewFolder() {
        const newFolderContract = {
            folderName: '',
            path: this.currentPath,
        };
        const dialogRef = this.dialog.open(NewFolderDialogComponent, {
            id: 'create-new-folder-dialog',
            width: '250px',
            data: newFolderContract,
        });
        dialogRef.afterClosed()
            .pipe(first())
            .forEach(({ folderName }) => {
            if (folderName) {
                const path = this.currentPath ?
                    `${this.currentPath}/${folderName}` : folderName;
                this.setStoragePath(path);
            }
        });
    }
    /**
     * Handles file upload logic, including validation and updating the
     * file listing upon successful upload. Logs errors if encountered.
     *
     * @param {FileList} files - An optional FileList of files to upload.
     */
    async uploadItems(files) {
        if (!files)
            return;
        // prevent file names to have ","(comma)
        if (Array.from(files).some((file) => file.name.includes(','))) {
            this.cLog.warn(`File names cannot include a ","(comma)`);
            return;
        }
        const uploadedFiles = [];
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const fileRef = this.storageService
                .getRef(`${this.currentPath}/${file.name}`);
            await this.storageService.uploadFile(fileRef, file)
                .then((snapshot) => uploadedFiles.push(snapshot))
                .catch((error) => {
                return this.handleUploadError(error, file.name);
            });
        }
        if (!uploadedFiles.length)
            return;
        this.reload(this.currentPath);
        /* eslint-disable-next-line max-len */
        this.cLog.info(`Uploaded ${uploadedFiles.length} ${uploadedFiles.length === 1 ? 'file' : 'files'}`, uploadedFiles);
    }
    /**
     * Event handler for file input change. Triggers the upload process.
     *
     * @param {Event} $event - The file input change event.
     */
    async onFilesSelect($event) {
        const files = $event.target.files;
        await this.uploadItems(files);
    }
    /**
     * Handles logging of errors during the file upload process.
     *
     * @param {FirebaseError} error - The Firebase error object.
     * @param {string} filename - The name of the file that failed to upload.
     */
    handleUploadError(error, filename) {
        this.cLog.error(error.code === 'storage/unauthorized' ?
            'You do not have permission to upload' :
            `Error uploading file: '${filename}'`, error);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: FileManagerComponent, deps: [{ token: i1.MatDialog }, { token: i2.ConsoleLoggerService }, { token: i3.FirebaseStorageService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.3.3", type: FileManagerComponent, isStandalone: true, selector: "anon-file-manager", inputs: { selection: "selection", selectedFile: "selectedFile", rootStoragePath: "rootStoragePath" }, ngImport: i0, template: "@if (items$ | async; as items) {\n  <div class=\"card\">\n    <input #inputUpload multiple class=\"inputUpload\"\n           type=\"file\" autocomplete=\"off\" tabindex=\"-1\"\n           (change)=\"onFilesSelect($event)\" />\n    <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n    @if (selection.isEmpty()) {\n      <header class=\"header\">\n        <!-- Crumbs -->\n        <span class=\"crumbs\">\n          <button mat-icon-button type=\"button\"\n                  [disabled]=\"currentPath===rootStoragePath\"\n                  (click)=\"setStoragePath(rootStoragePath)\">\n            <mat-icon fontIcon=\"home\" />\n          </button>\n          <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n          @for (crumb of currentPath.split('/'); track crumb;let i=$index; let last=$last) {\n            @if (crumb !== rootStoragePath) {\n              @if (currentPath!==rootStoragePath) {\n                <mat-icon class=\"overflow-visible\" fontIcon=\"chevron_right\" />\n              }\n              <button mat-button type=\"button\" [disabled]=\"last\"\n                      (click)=\"setStoragePath(getCrumbPath(currentPath.split('/'), i))\">\n              {{crumb}}\n            </button>\n            }\n          }\n        </span>\n\n        <button mat-icon-button type=\"button\" (click)=\"reload()\">\n          <mat-icon fontIcon=\"refresh\" />\n        </button>\n        <button mat-icon-button type=\"button\" (click)=\"createNewFolder()\">\n          <mat-icon fontIcon=\"create_new_folder\" />\n        </button>\n        <div>\n          <button mat-flat-button type=\"button\" color=\"primary\"\n                  (click)=\"inputUpload.click()\">Upload</button>\n        </div>\n      </header>\n    } @else {\n      <header class=\"header items-selected\">\n        <button mat-icon-button type=\"button\" (click)=\"selection.clear()\">\n          <mat-icon fontIcon=\"close\" />\n        </button>\n        <span>{{selection.selected.length}} {{selection.selected.length === 1 ? 'item' : 'items'}}</span>\n        <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n        <button mat-raised-button type=\"button\" color=\"accent\" [disabled]=\"selectionIncludesFolder\"\n                (click)=\"downloadFiles(selection.selected)\">Download files</button>\n        <button mat-stroked-button type=\"button\"\n                (click)=\"deleteItems(selection.selected)\">Delete</button>\n      </header>\n    }\n\n    <div class=\"content\">\n      <div class=\"table-sidebar\">\n        <div class=\"table-wrapper\" [ngClass]=\"{'grid-column-end-span-8': selectedFile}\">\n          <table mat-table [dataSource]=\"items\">\n            <!-- Checkbox Column -->\n            <ng-container matColumnDef=\"checkbox\">\n              <th *matHeaderCellDef mat-header-cell class=\"checkbox-column\">\n                <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n                <mat-checkbox name=\"select-all\" [checked]=\"allItemsSelected(items)\" [indeterminate]=\"allItemsIndeterminate(items)\"\n                              [disabled]=\"items.length === 0\"\n                              (change)=\"toggleAllItems($event.checked, items)\" />\n              </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"checkbox-column\">\n                <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n                <mat-checkbox [checked]=\"selection.isSelected(item)\"\n                              (click)=\"$event.stopPropagation()\"\n                              (change)=\"selection.toggle(item)\" />\n              </td>\n            </ng-container>\n\n            <!-- Name Column -->\n            <ng-container matColumnDef=\"name\">\n              <th *matHeaderCellDef mat-header-cell> Name </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"name-column\">\n                <anon-storage-item-icon [type]=\"item.type\" [contentType]=\"item.contentType\" />\n                <span>{{item.name}}</span>\n              </td>\n            </ng-container>\n\n            <!-- Size Column -->\n            <ng-container matColumnDef=\"size\">\n              <th *matHeaderCellDef mat-header-cell> Size </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.size | formatBytes}}\n              </td>\n            </ng-container>\n\n            <!-- Type Column -->\n            <ng-container matColumnDef=\"type\">\n              <th *matHeaderCellDef mat-header-cell> Type </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? 'Folder' : item.contentType}}\n              </td>\n            </ng-container>\n\n            <!-- Last Modified Column -->\n            <ng-container matColumnDef=\"lastModified\">\n              <th *matHeaderCellDef mat-header-cell> Last Modified </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.updated | date}}\n              </td>\n            </ng-container>\n\n            <tr *matHeaderRowDef=\"tableColumns; sticky: true\" mat-header-row></tr>\n            <tr *matRowDef=\"let item; columns: tableColumns;\" mat-row\n                [class.selected]=\"selectedFile === item\"\n                (click)=\"storageItemSelected(item)\"></tr>\n          </table>\n        </div>\n\n        @if (selectedFile) {\n          <aside class=\"sidebar grid-column-end-span-4\">\n            <anon-storage-file-preview [item]=\"selectedFile\" (_close)=\"selectedFile = undefined\" />\n          </aside>\n        }\n      </div>\n\n      @if (!items.length) {\n        <div anonFileDropzone class=\"empty-folder\"\n             hoverClass=\"hovering\" tabindex=\"0\"\n             (click)=\"inputUpload.click()\"\n             (keyup)=\"inputUpload.click()\"\n             (dropped)=\"uploadItems($event)\">\n          <div>No files found</div>\n          <div>Drag and drop files to upload</div>\n        </div>\n      }\n    </div>\n  </div>\n} @else {\n  <anon-loading-or-error [error]=\"error\" />\n}\n", styles: [".card{display:flex;flex-direction:column;border-radius:1rem;overflow:hidden;max-height:600px}header.header{height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 1rem}header.header.items-selected{justify-content:flex-start;gap:1rem}header.header.items-selected mat-icon{color:inherit}.crumbs{flex-grow:1;display:flex;align-items:center;width:100px;overflow-x:auto;overflow-y:hidden}.inputUpload{display:none}.content{display:flex;flex-direction:column;overflow:hidden}.table-sidebar{width:100%;display:grid;margin:0;grid-gap:1.5rem;grid-template-columns:repeat(12,minmax(0,1fr));overflow:hidden}.table-wrapper{grid-column-end:span 12;border-top-width:1px;border-top-style:solid;border-bottom-width:1px;border-bottom-style:solid;display:inline-flex;flex-direction:column;overflow:auto;border-radius:0 0 8px 8px;width:100%}table{min-width:100%;border:0;white-space:nowrap;border-collapse:collapse;table-layout:fixed}.checkbox-column{width:64px}.name-column{max-width:50vw;display:flex;align-items:center;height:auto;min-height:52px;overflow-wrap:break-word;white-space:pre;padding:.75rem 1rem .75rem 0}.name-column span{display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;overflow:hidden;width:100%}aside.sidebar{width:auto;margin:0}td{border:none!important}.mat-mdc-header-cell,.mat-mdc-cell{height:auto;min-height:52px;padding:0 1rem}.mat-mdc-row{cursor:pointer}.empty-folder{display:flex;flex-direction:column;justify-content:center;align-items:center;height:200px}.grid-column-end-span-4{grid-column-end:span 4}.grid-column-end-span-8{grid-column-end:span 8}.grid-column-end-span-12{grid-column-end:span 12}\n"], dependencies: [{ kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "ngmodule", type: MatButtonModule }, { kind: "component", type: i4.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", exportAs: ["matButton"] }, { kind: "component", type: i4.MatIconButton, selector: "button[mat-icon-button]", exportAs: ["matButton"] }, { kind: "ngmodule", type: MatIconModule }, { kind: "component", type: i5.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "ngmodule", type: MatTableModule }, { kind: "component", type: i6.MatTable, selector: "mat-table, table[mat-table]", exportAs: ["matTable"] }, { kind: "directive", type: i6.MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { kind: "directive", type: i6.MatHeaderRowDef, selector: "[matHeaderRowDef]", inputs: ["matHeaderRowDef", "matHeaderRowDefSticky"] }, { kind: "directive", type: i6.MatColumnDef, selector: "[matColumnDef]", inputs: ["matColumnDef"] }, { kind: "directive", type: i6.MatCellDef, selector: "[matCellDef]" }, { kind: "directive", type: i6.MatRowDef, selector: "[matRowDef]", inputs: ["matRowDefColumns", "matRowDefWhen"] }, { kind: "directive", type: i6.MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { kind: "directive", type: i6.MatCell, selector: "mat-cell, td[mat-cell]" }, { kind: "component", type: i6.MatHeaderRow, selector: "mat-header-row, tr[mat-header-row]", exportAs: ["matHeaderRow"] }, { kind: "component", type: i6.MatRow, selector: "mat-row, tr[mat-row]", exportAs: ["matRow"] }, { kind: "ngmodule", type: MatCheckboxModule }, { kind: "component", type: i7.MatCheckbox, selector: "mat-checkbox", inputs: ["aria-label", "aria-labelledby", "aria-describedby", "id", "required", "labelPosition", "name", "value", "disableRipple", "tabIndex", "color", "checked", "disabled", "indeterminate"], outputs: ["change", "indeterminateChange"], exportAs: ["matCheckbox"] }, { kind: "component", type: StorageItemIconComponent, selector: "anon-storage-item-icon", inputs: ["type", "contentType"] }, { kind: "pipe", type: FormatBytesPipe, name: "formatBytes" }, { kind: "pipe", type: DatePipe, name: "date" }, { kind: "component", type: StorageFilePreviewComponent, selector: "anon-storage-file-preview", inputs: ["item"], outputs: ["_close"] }, { kind: "directive", type: FileDropzoneDirective, selector: "[anonFileDropzone]", inputs: ["hoverClass"], outputs: ["dropped", "hovered"] }, { kind: "component", type: LoadingOrErrorComponent, selector: "anon-loading-or-error", inputs: ["error"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: FileManagerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'anon-file-manager', standalone: true, imports: [
                        AsyncPipe,
                        MatButtonModule,
                        MatIconModule,
                        MatTableModule,
                        MatCheckboxModule,
                        StorageItemIconComponent,
                        FormatBytesPipe,
                        DatePipe,
                        StorageFilePreviewComponent,
                        FileDropzoneDirective,
                        LoadingOrErrorComponent,
                        NgClass,
                    ], template: "@if (items$ | async; as items) {\n  <div class=\"card\">\n    <input #inputUpload multiple class=\"inputUpload\"\n           type=\"file\" autocomplete=\"off\" tabindex=\"-1\"\n           (change)=\"onFilesSelect($event)\" />\n    <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n    @if (selection.isEmpty()) {\n      <header class=\"header\">\n        <!-- Crumbs -->\n        <span class=\"crumbs\">\n          <button mat-icon-button type=\"button\"\n                  [disabled]=\"currentPath===rootStoragePath\"\n                  (click)=\"setStoragePath(rootStoragePath)\">\n            <mat-icon fontIcon=\"home\" />\n          </button>\n          <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n          @for (crumb of currentPath.split('/'); track crumb;let i=$index; let last=$last) {\n            @if (crumb !== rootStoragePath) {\n              @if (currentPath!==rootStoragePath) {\n                <mat-icon class=\"overflow-visible\" fontIcon=\"chevron_right\" />\n              }\n              <button mat-button type=\"button\" [disabled]=\"last\"\n                      (click)=\"setStoragePath(getCrumbPath(currentPath.split('/'), i))\">\n              {{crumb}}\n            </button>\n            }\n          }\n        </span>\n\n        <button mat-icon-button type=\"button\" (click)=\"reload()\">\n          <mat-icon fontIcon=\"refresh\" />\n        </button>\n        <button mat-icon-button type=\"button\" (click)=\"createNewFolder()\">\n          <mat-icon fontIcon=\"create_new_folder\" />\n        </button>\n        <div>\n          <button mat-flat-button type=\"button\" color=\"primary\"\n                  (click)=\"inputUpload.click()\">Upload</button>\n        </div>\n      </header>\n    } @else {\n      <header class=\"header items-selected\">\n        <button mat-icon-button type=\"button\" (click)=\"selection.clear()\">\n          <mat-icon fontIcon=\"close\" />\n        </button>\n        <span>{{selection.selected.length}} {{selection.selected.length === 1 ? 'item' : 'items'}}</span>\n        <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n        <button mat-raised-button type=\"button\" color=\"accent\" [disabled]=\"selectionIncludesFolder\"\n                (click)=\"downloadFiles(selection.selected)\">Download files</button>\n        <button mat-stroked-button type=\"button\"\n                (click)=\"deleteItems(selection.selected)\">Delete</button>\n      </header>\n    }\n\n    <div class=\"content\">\n      <div class=\"table-sidebar\">\n        <div class=\"table-wrapper\" [ngClass]=\"{'grid-column-end-span-8': selectedFile}\">\n          <table mat-table [dataSource]=\"items\">\n            <!-- Checkbox Column -->\n            <ng-container matColumnDef=\"checkbox\">\n              <th *matHeaderCellDef mat-header-cell class=\"checkbox-column\">\n                <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n                <mat-checkbox name=\"select-all\" [checked]=\"allItemsSelected(items)\" [indeterminate]=\"allItemsIndeterminate(items)\"\n                              [disabled]=\"items.length === 0\"\n                              (change)=\"toggleAllItems($event.checked, items)\" />\n              </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"checkbox-column\">\n                <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n                <mat-checkbox [checked]=\"selection.isSelected(item)\"\n                              (click)=\"$event.stopPropagation()\"\n                              (change)=\"selection.toggle(item)\" />\n              </td>\n            </ng-container>\n\n            <!-- Name Column -->\n            <ng-container matColumnDef=\"name\">\n              <th *matHeaderCellDef mat-header-cell> Name </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"name-column\">\n                <anon-storage-item-icon [type]=\"item.type\" [contentType]=\"item.contentType\" />\n                <span>{{item.name}}</span>\n              </td>\n            </ng-container>\n\n            <!-- Size Column -->\n            <ng-container matColumnDef=\"size\">\n              <th *matHeaderCellDef mat-header-cell> Size </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.size | formatBytes}}\n              </td>\n            </ng-container>\n\n            <!-- Type Column -->\n            <ng-container matColumnDef=\"type\">\n              <th *matHeaderCellDef mat-header-cell> Type </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? 'Folder' : item.contentType}}\n              </td>\n            </ng-container>\n\n            <!-- Last Modified Column -->\n            <ng-container matColumnDef=\"lastModified\">\n              <th *matHeaderCellDef mat-header-cell> Last Modified </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.updated | date}}\n              </td>\n            </ng-container>\n\n            <tr *matHeaderRowDef=\"tableColumns; sticky: true\" mat-header-row></tr>\n            <tr *matRowDef=\"let item; columns: tableColumns;\" mat-row\n                [class.selected]=\"selectedFile === item\"\n                (click)=\"storageItemSelected(item)\"></tr>\n          </table>\n        </div>\n\n        @if (selectedFile) {\n          <aside class=\"sidebar grid-column-end-span-4\">\n            <anon-storage-file-preview [item]=\"selectedFile\" (_close)=\"selectedFile = undefined\" />\n          </aside>\n        }\n      </div>\n\n      @if (!items.length) {\n        <div anonFileDropzone class=\"empty-folder\"\n             hoverClass=\"hovering\" tabindex=\"0\"\n             (click)=\"inputUpload.click()\"\n             (keyup)=\"inputUpload.click()\"\n             (dropped)=\"uploadItems($event)\">\n          <div>No files found</div>\n          <div>Drag and drop files to upload</div>\n        </div>\n      }\n    </div>\n  </div>\n} @else {\n  <anon-loading-or-error [error]=\"error\" />\n}\n", styles: [".card{display:flex;flex-direction:column;border-radius:1rem;overflow:hidden;max-height:600px}header.header{height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 1rem}header.header.items-selected{justify-content:flex-start;gap:1rem}header.header.items-selected mat-icon{color:inherit}.crumbs{flex-grow:1;display:flex;align-items:center;width:100px;overflow-x:auto;overflow-y:hidden}.inputUpload{display:none}.content{display:flex;flex-direction:column;overflow:hidden}.table-sidebar{width:100%;display:grid;margin:0;grid-gap:1.5rem;grid-template-columns:repeat(12,minmax(0,1fr));overflow:hidden}.table-wrapper{grid-column-end:span 12;border-top-width:1px;border-top-style:solid;border-bottom-width:1px;border-bottom-style:solid;display:inline-flex;flex-direction:column;overflow:auto;border-radius:0 0 8px 8px;width:100%}table{min-width:100%;border:0;white-space:nowrap;border-collapse:collapse;table-layout:fixed}.checkbox-column{width:64px}.name-column{max-width:50vw;display:flex;align-items:center;height:auto;min-height:52px;overflow-wrap:break-word;white-space:pre;padding:.75rem 1rem .75rem 0}.name-column span{display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;overflow:hidden;width:100%}aside.sidebar{width:auto;margin:0}td{border:none!important}.mat-mdc-header-cell,.mat-mdc-cell{height:auto;min-height:52px;padding:0 1rem}.mat-mdc-row{cursor:pointer}.empty-folder{display:flex;flex-direction:column;justify-content:center;align-items:center;height:200px}.grid-column-end-span-4{grid-column-end:span 4}.grid-column-end-span-8{grid-column-end:span 8}.grid-column-end-span-12{grid-column-end:span 12}\n"] }]
        }], ctorParameters: () => [{ type: i1.MatDialog }, { type: i2.ConsoleLoggerService }, { type: i3.FirebaseStorageService }], propDecorators: { selection: [{
                type: Input
            }], selectedFile: [{
                type: Input
            }], rootStoragePath: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItZmlyZWJhc2Utc3RvcmFnZS1tYW5hZ2VyL3NyYy9saWIvZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItZmlyZWJhc2Utc3RvcmFnZS1tYW5hZ2VyL3NyYy9saWIvZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFVLE1BQU0sZUFBZSxDQUFDO0FBS3pELE9BQU8sRUFFTCx3QkFBd0IsR0FDekIsTUFBTSw0REFBNEQsQ0FBQztBQUVwRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDMUQsT0FBTyxFQUNMLDBCQUEwQixHQUMzQixNQUFNLGdFQUFnRSxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9ELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDdkQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3pELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQy9ELE9BQU8sRUFDTCx3QkFBd0IsR0FDekIsTUFBTSw0REFBNEQsQ0FBQztBQUNwRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDNUQsT0FBTyxFQUNMLDJCQUEyQixHQUM1QixNQUFNLGtFQUFrRSxDQUFDO0FBQzFFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQzdFLE9BQU8sRUFDTCx1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UixLQUFLO2dCQU9OLFlBQVk7c0JBRFgsS0FBSztnQkFPTixlQUFlO3NCQURkLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZpcmViYXNlU3RvcmFnZVNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL2ZpcmViYXNlLXN0b3JhZ2Uuc2VydmljZSc7XG5pbXBvcnQgeyBTdG9yYWdlUmVmZXJlbmNlLCBVcGxvYWRSZXN1bHQgfSBmcm9tICdAYW5ndWxhci9maXJlL3N0b3JhZ2UnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0Bhbmd1bGFyL2ZpcmUvYXBwL2ZpcmViYXNlJztcbmltcG9ydCB7IE1hdERpYWxvZyB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2RpYWxvZyc7XG5pbXBvcnQge1xuICBOZXdGb2xkZXJEaWFsb2dDbG9zZUNvbnRyYWN0LFxuICBOZXdGb2xkZXJEaWFsb2dDb21wb25lbnQsIE5ld0ZvbGRlckRpYWxvZ0NvbnRyYWN0LFxufSBmcm9tICcuL2NvbXBvbmVudHMvbmV3LWZvbGRlci1kaWFsb2cvbmV3LWZvbGRlci1kaWFsb2cuY29tcG9uZW50JztcbmltcG9ydCB7IFN0b3JhZ2VJdGVtLCBTdG9yYWdlRmlsZSB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTZWxlY3Rpb25Nb2RlbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XG5pbXBvcnQge1xuICBEZWxldGVGaWxlc0RpYWxvZ0NvbXBvbmVudCxcbn0gZnJvbSAnLi9jb21wb25lbnRzL2RlbGV0ZS1maWxlcy1kaWFsb2cvZGVsZXRlLWZpbGVzLWRpYWxvZy5jb21wb25lbnQnO1xuaW1wb3J0IHsgQXN5bmNQaXBlLCBEYXRlUGlwZSwgTmdDbGFzcyB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBNYXRCdXR0b25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9idXR0b24nO1xuaW1wb3J0IHsgTWF0SWNvbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2ljb24nO1xuaW1wb3J0IHsgTWF0VGFibGVNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC90YWJsZSc7XG5pbXBvcnQgeyBNYXRDaGVja2JveE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2NoZWNrYm94JztcbmltcG9ydCB7XG4gIFN0b3JhZ2VJdGVtSWNvbkNvbXBvbmVudCxcbn0gZnJvbSAnLi9jb21wb25lbnRzL3N0b3JhZ2UtaXRlbS1pY29uL3N0b3JhZ2UtaXRlbS1pY29uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGb3JtYXRCeXRlc1BpcGUgfSBmcm9tICcuL3BpcGVzL2Zvcm1hdC1ieXRlcy5waXBlJztcbmltcG9ydCB7XG4gIFN0b3JhZ2VGaWxlUHJldmlld0NvbXBvbmVudCxcbn0gZnJvbSAnLi9jb21wb25lbnRzL3N0b3JhZ2UtZmlsZS1wcmV2aWV3L3N0b3JhZ2UtZmlsZS1wcmV2aWV3LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGaWxlRHJvcHpvbmVEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvZmlsZS1kcm9wem9uZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHtcbiAgTG9hZGluZ09yRXJyb3JDb21wb25lbnQsXG59IGZyb20gJy4vY29tcG9uZW50cy9sb2FkaW5nLW9yLWVycm9yL2xvYWRpbmctb3ItZXJyb3IuY29tcG9uZW50JztcbmltcG9ydCB7IENvbnNvbGVMb2dnZXJTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9jb25zb2xlLWxvZ2dlci5zZXJ2aWNlJztcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSAncnhqcyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Fub24tZmlsZS1tYW5hZ2VyJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2ZpbGUtbWFuYWdlci5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsOiAnLi9maWxlLW1hbmFnZXIuY29tcG9uZW50LnNjc3MnLFxuICBzdGFuZGFsb25lOiB0cnVlLFxuICBpbXBvcnRzOiBbXG4gICAgQXN5bmNQaXBlLFxuICAgIE1hdEJ1dHRvbk1vZHVsZSxcbiAgICBNYXRJY29uTW9kdWxlLFxuICAgIE1hdFRhYmxlTW9kdWxlLFxuICAgIE1hdENoZWNrYm94TW9kdWxlLFxuICAgIFN0b3JhZ2VJdGVtSWNvbkNvbXBvbmVudCxcbiAgICBGb3JtYXRCeXRlc1BpcGUsXG4gICAgRGF0ZVBpcGUsXG4gICAgU3RvcmFnZUZpbGVQcmV2aWV3Q29tcG9uZW50LFxuICAgIEZpbGVEcm9wem9uZURpcmVjdGl2ZSxcbiAgICBMb2FkaW5nT3JFcnJvckNvbXBvbmVudCxcbiAgICBOZ0NsYXNzLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBGaWxlTWFuYWdlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIC8qKlxuICAgKiBUaGUgY29sdW1ucyB0byBkaXNwbGF5IGluIHRoZSBmaWxlIG1hbmFnZW1lbnQgdGFibGUuXG4gICAqL1xuICB0YWJsZUNvbHVtbnM6IHN0cmluZ1tdID0gWydjaGVja2JveCcsICduYW1lJywgJ3NpemUnLCAndHlwZScsICdsYXN0TW9kaWZpZWQnXTtcbiAgLyoqXG4gICAqIEEgUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgU3RvcmFnZUl0ZW0gb2JqZWN0cyByZXByZXNlbnRpbmdcbiAgICogdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGNvbnRlbnRzLCBvciB1bmRlZmluZWQgaWYgYW4gZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgaXRlbXMkPzogUHJvbWlzZTxTdG9yYWdlSXRlbVtdPiB8IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHBhdGggd2l0aGluIHRoZSBzdG9yYWdlIHN5c3RlbS5cbiAgICovXG4gIGN1cnJlbnRQYXRoID0gJyc7XG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgcG90ZW50aWFsIEZpcmViYXNlRXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIGZpbGUgb3BlcmF0aW9ucy5cbiAgICovXG4gIGVycm9yPzogRmlyZWJhc2VFcnJvcjtcblxuICAvKipcbiAgICogVXNlZCBmb3IgbWFuYWdpbmcgbXVsdGlwbGUgaXRlbSBzZWxlY3Rpb24gd2l0aGluIHRoZSBmaWxlIG1hbmFnZXIuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uTW9kZWw8U3RvcmFnZUl0ZW0+KHRydWUsIFtdKTtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmaWxlIChpZiBhbnkpLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2VsZWN0ZWRGaWxlOiBTdG9yYWdlRmlsZSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIHJvb3QgcGF0aCB3aXRoaW4gdGhlIHN0b3JhZ2Ugc3lzdGVtIHdoZXJlIHRoZSBmaWxlIG1hbmFnZXIgb3BlcmF0ZXMuXG4gICAqL1xuICBASW5wdXQoKVxuICByb290U3RvcmFnZVBhdGggPSAnJztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGRpYWxvZzogTWF0RGlhbG9nLFxuICAgIHByaXZhdGUgY0xvZzogQ29uc29sZUxvZ2dlclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBzdG9yYWdlU2VydmljZTogRmlyZWJhc2VTdG9yYWdlU2VydmljZSxcbiAgKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIC8qKiBTZXRzIHRoZSBpbml0aWFsIHBhdGggd2l0aGluIHRoZSBzdG9yYWdlIHN5c3RlbSAqL1xuICAgIHRoaXMuY3VycmVudFBhdGggPSB0aGlzLnJvb3RTdG9yYWdlUGF0aDtcbiAgICAvKiogRmV0Y2hlcyB0aGUgaW5pdGlhbCBzdG9yYWdlIGl0ZW1zICovXG4gICAgdGhpcy5pdGVtcyQgPSB0aGlzLmdldEFsbFN0b3JhZ2VJdGVtcyh0aGlzLmN1cnJlbnRQYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEb3dubG9hZHMgdGhlIHByb3ZpZGVkIGZpbGVzIGJ5IHRyaWdnZXJpbmcgZG93bmxvYWQgbGlua3MuXG4gICAqIEBwYXJhbSB7U3RvcmFnZUl0ZW1bXX0gZmlsZXMgLSBUaGUgZmlsZXMgdG8gZG93bmxvYWQuXG4gICAqL1xuICBhc3luYyBkb3dubG9hZEZpbGVzKGZpbGVzOiBTdG9yYWdlSXRlbVtdKSB7XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlU2VydmljZS5vcGVuQWxsRmlsZXMoZmlsZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHNlbGVjdGlvbiBvZiBhbGwgaXRlbXMgaW4gdGhlIGZpbGUgbGlzdGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkIC0gV2hldGhlciB0byBzZWxlY3Qgb3IgZGVzZWxlY3QgYWxsIGl0ZW1zLlxuICAgKiBAcGFyYW0ge1N0b3JhZ2VJdGVtW119IGl0ZW1zIC0gVGhlIGxpc3Qgb2YgZmlsZSBpdGVtcy5cbiAgICovXG4gIHRvZ2dsZUFsbEl0ZW1zKGNoZWNrZWQ6IGJvb2xlYW4sIGl0ZW1zOiBTdG9yYWdlSXRlbVtdKSB7XG4gICAgaWYgKCFjaGVja2VkKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3QoLi4uaXRlbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhbGwgaXRlbXMgaW4gdGhlIGZpbGUgbGlzdGluZyBhcmUgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0b3JhZ2VJdGVtW119IGl0ZW1zIC0gVGhlIGxpc3Qgb2YgZmlsZSBpdGVtcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbGwgaXRlbXMgYXJlIHNlbGVjdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBhbGxJdGVtc1NlbGVjdGVkKGl0ZW1zOiBTdG9yYWdlSXRlbVtdKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGVkLmxlbmd0aCA9PT0gaXRlbXMubGVuZ3RoICYmXG4gICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RlZC5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBzb21lLCBidXQgbm90IGFsbCwgaXRlbXMgaW4gdGhlIGZpbGUgbGlzdGluZyBhcmUgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RvcmFnZUl0ZW1bXX0gaXRlbXMgLSBUaGUgbGlzdCBvZiBmaWxlIGl0ZW1zLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzZWxlY3Rpb24gc3RhdGUgaXMgaW5kZXRlcm1pbmF0ZSwgZmFsc2VcbiAgICogb3RoZXJ3aXNlLlxuICAgKi9cbiAgYWxsSXRlbXNJbmRldGVybWluYXRlKGl0ZW1zOiBTdG9yYWdlSXRlbVtdKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGVkLmxlbmd0aCA+IDAgJiZcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGVkLmxlbmd0aCA8IGl0ZW1zLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciB3aGVuIGEgc3RvcmFnZSBpdGVtIGlzIHNlbGVjdGVkLiBVcGRhdGVzIHRoZSBuYXZpZ2F0aW9uXG4gICAqIGlmIGEgZm9sZGVyIGlzIHNlbGVjdGVkLCBvciBzZXRzIHRoZSBzZWxlY3RlZCBmaWxlIGlmIGEgZmlsZSBpcyBzZWxlY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdG9yYWdlSXRlbX0gaXRlbSAtIFRoZSBzZWxlY3RlZCBTdG9yYWdlSXRlbS5cbiAgICovXG4gIHN0b3JhZ2VJdGVtU2VsZWN0ZWQoaXRlbTogU3RvcmFnZUl0ZW0pIHtcbiAgICBpZiAoaXRlbS50eXBlID09PSAnZm9sZGVyJykgdGhpcy5zZXRTdG9yYWdlUGF0aChpdGVtLmZ1bGxQYXRoKTtcbiAgICBlbHNlIGlmIChpdGVtLnR5cGUgPT09ICdmaWxlJykgdGhpcy5zZWxlY3RlZEZpbGUgPSBpdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaW5jbHVkZXMgYXQgbGVhc3Qgb25lIGZvbGRlci5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGZvbGRlciBpcyBwYXJ0IG9mIHRoZSBzZWxlY3Rpb24sIGZhbHNlXG4gICAqIG90aGVyd2lzZS5cbiAgICovXG4gIGdldCBzZWxlY3Rpb25JbmNsdWRlc0ZvbGRlcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uc2VsZWN0ZWQuc29tZSgoaXRlbSkgPT4gaXRlbS50eXBlID09PSAnZm9sZGVyJyk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgYSBkaWFsb2cgdG8gY29uZmlybSBkZWxldGlvbiwgYW5kIGhhbmRsZXMgZGVsZXRpbmcgc2VsZWN0ZWQgaXRlbXNcbiAgICogaWYgY29uZmlybWVkLiBDbGVhcnMgdGhlIHNlbGVjdGlvbiBhbmQgdXBkYXRlcyB0aGUgZmlsZSBsaXN0aW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0b3JhZ2VJdGVtW119IGl0ZW1zIC0gVGhlIGl0ZW1zIHRvIGRlbGV0ZS5cbiAgICovXG4gIGRlbGV0ZUl0ZW1zKGl0ZW1zOiBTdG9yYWdlSXRlbVtdKSB7XG4gICAgY29uc3QgZGlhbG9nUmVmID0gdGhpcy5kaWFsb2cub3BlbihEZWxldGVGaWxlc0RpYWxvZ0NvbXBvbmVudCwge1xuICAgICAgaWQ6ICdkZWxldGUtZmlsZXMtZGlhbG9nJyxcbiAgICAgIG1pbldpZHRoOiAnMjUwcHgnLFxuICAgIH0pO1xuICAgIGRpYWxvZ1JlZi5hZnRlckNsb3NlZCgpLnBpcGUoZmlyc3QoKSkuZm9yRWFjaCgoY29uZmlybTogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoY29uZmlybSkge1xuICAgICAgICAgIHRoaXMuc3RvcmFnZVNlcnZpY2UuZGVsZXRlRmlsZXMoaXRlbXMpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICAgICAgICAgIGlmIChpdGVtcy5zb21lKChpdGVtKSA9PiBpdGVtID09IHRoaXMuc2VsZWN0ZWRGaWxlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRGaWxlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5yZWxvYWQodGhpcy5jdXJyZW50UGF0aCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgYnJlYWRjcnVtYi1zdHlsZSBwYXRoIHN0cmluZyBiYXNlZCBvbiB0aGUgY3VycmVudCBwYXRoXG4gICAqIGhpc3RvcnkuIFVzZWQgZm9yIG5hdmlnYXRpb24gZGlzcGxheS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aEFycmF5IC0gQW4gYXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHVwIHRvIHdoaWNoIHBhdGggc2VnbWVudHMgc2hvdWxkIGJlXG4gICAqIGluY2x1ZGVkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb25zdHJ1Y3RlZCBwYXRoIHN0cmluZy5cbiAgICovXG4gIGdldENydW1iUGF0aChwYXRoQXJyYXk6IHN0cmluZ1tdLCBpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBwYXRoQXJyYXkubGVuZ3RoID0gaW5kZXggKyAxO1xuICAgIHJldHVybiBwYXRoQXJyYXkuam9pbignLycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgcGF0aCBhbmQgZmV0Y2hlcyB0aGUgbmV3IGZpbGUgbGlzdGluZy5cbiAgICogQ2xlYXJzIGFueSBleGlzdGluZyBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIG5ldyBzdG9yYWdlIHBhdGguXG4gICAqL1xuICBzZXRTdG9yYWdlUGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgICB0aGlzLml0ZW1zJCA9IHRoaXMuZ2V0QWxsU3RvcmFnZUl0ZW1zKHBhdGgpO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBwYXRoO1xuICAgIGlmICh0aGlzLnNlbGVjdGlvbi5oYXNWYWx1ZSgpKSB0aGlzLnNlbGVjdGlvbi5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbmQgcHJvY2Vzc2VzIGFsbCBpdGVtcyB3aXRoaW4gYSBnaXZlbiBzdG9yYWdlIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHN0b3JhZ2UgcGF0aCB0byBsaXN0LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFN0b3JhZ2VJdGVtW10+fSBBIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBpdGVtcyxcbiAgICogb3IgdW5kZWZpbmVkIGluIGNhc2Ugb2YgZXJyb3IuXG4gICAqL1xuICBhc3luYyBnZXRBbGxTdG9yYWdlSXRlbXMocGF0aDogc3RyaW5nKTogUHJvbWlzZTxTdG9yYWdlSXRlbVtdPiB7XG4gICAgY29uc3Qgc3RvcmFnZVJlZjogU3RvcmFnZVJlZmVyZW5jZSA9IHRoaXMuc3RvcmFnZVNlcnZpY2UuZ2V0UmVmKHBhdGgpO1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VTZXJ2aWNlLmxpc3RBbGwoc3RvcmFnZVJlZilcbiAgICAgIC50aGVuKGFzeW5jICh7IGl0ZW1zLCBwcmVmaXhlcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbEl0ZW1zOiBTdG9yYWdlSXRlbVtdID0gW1xuICAgICAgICAgIC4uLnByZWZpeGVzLm1hcCh0aGlzLnN0b3JhZ2VTZXJ2aWNlLmltcG9ydEZvbGRlciksXG4gICAgICAgICAgLi4uKGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcCh0aGlzLnN0b3JhZ2VTZXJ2aWNlLmltcG9ydEZpbGUpKSksXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBhbGxJdGVtcztcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yOiBGaXJlYmFzZUVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxvYWRzIHRoZSBmaWxlIGFuZCBmb2xkZXIgbGlzdGluZyB3aXRoaW4gdGhlIGN1cnJlbnQgb3Igc3BlY2lmaWVkIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gcGF0aCAtIE9wdGlvbmFsLiBUaGUgcGF0aCB0byByZWxvYWQuIElmIG51bGwsXG4gICAqIHRoZSBjdXJyZW50IHBhdGggaXMgdXNlZC5cbiAgICovXG4gIHJlbG9hZChwYXRoOiBzdHJpbmcgfCBudWxsID0gbnVsbCkge1xuICAgIGxldCBwYXRoUmVmOiBTdG9yYWdlUmVmZXJlbmNlO1xuICAgIGlmIChwYXRoKSBwYXRoUmVmID0gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRSZWYocGF0aCk7XG4gICAgZWxzZSBwYXRoUmVmID0gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRSZWYodGhpcy5jdXJyZW50UGF0aCk7XG5cbiAgICB0aGlzLml0ZW1zJCA9IHRoaXMuc3RvcmFnZVNlcnZpY2UubGlzdEFsbChwYXRoUmVmKVxuICAgICAgLnRoZW4oYXN5bmMgKHsgaXRlbXMsIHByZWZpeGVzIH0pID0+IFtcbiAgICAgICAgLi4ucHJlZml4ZXMubWFwKHRoaXMuc3RvcmFnZVNlcnZpY2UuaW1wb3J0Rm9sZGVyKSxcbiAgICAgICAgLi4uKGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcCh0aGlzLnN0b3JhZ2VTZXJ2aWNlLmltcG9ydEZpbGUpKSksXG4gICAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyBhIGRpYWxvZyB0byBjcmVhdGUgYSBuZXcgZm9sZGVyIGFuZCB1cGRhdGVzIGZvbGRlciBsaXN0aW5nXG4gICAqIGlmIHN1Y2Nlc3NmdWwuXG4gICAqL1xuICBjcmVhdGVOZXdGb2xkZXIoKSB7XG4gICAgY29uc3QgbmV3Rm9sZGVyQ29udHJhY3Q6IE5ld0ZvbGRlckRpYWxvZ0NvbnRyYWN0ID0ge1xuICAgICAgZm9sZGVyTmFtZTogJycsXG4gICAgICBwYXRoOiB0aGlzLmN1cnJlbnRQYXRoLFxuICAgIH07XG4gICAgY29uc3QgZGlhbG9nUmVmID0gdGhpcy5kaWFsb2cub3BlbihOZXdGb2xkZXJEaWFsb2dDb21wb25lbnQsIHtcbiAgICAgIGlkOiAnY3JlYXRlLW5ldy1mb2xkZXItZGlhbG9nJyxcbiAgICAgIHdpZHRoOiAnMjUwcHgnLFxuICAgICAgZGF0YTogbmV3Rm9sZGVyQ29udHJhY3QsXG4gICAgfSk7XG4gICAgZGlhbG9nUmVmLmFmdGVyQ2xvc2VkKClcbiAgICAgIC5waXBlKGZpcnN0KCkpXG4gICAgICAuZm9yRWFjaCgoeyBmb2xkZXJOYW1lIH06IE5ld0ZvbGRlckRpYWxvZ0Nsb3NlQ29udHJhY3QpID0+IHtcbiAgICAgICAgaWYgKGZvbGRlck5hbWUpIHtcbiAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5jdXJyZW50UGF0aCA/XG4gICAgICAgICAgICBgJHt0aGlzLmN1cnJlbnRQYXRofS8ke2ZvbGRlck5hbWV9YCA6IGZvbGRlck5hbWU7XG4gICAgICAgICAgdGhpcy5zZXRTdG9yYWdlUGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBmaWxlIHVwbG9hZCBsb2dpYywgaW5jbHVkaW5nIHZhbGlkYXRpb24gYW5kIHVwZGF0aW5nIHRoZVxuICAgKiBmaWxlIGxpc3RpbmcgdXBvbiBzdWNjZXNzZnVsIHVwbG9hZC4gTG9ncyBlcnJvcnMgaWYgZW5jb3VudGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RmlsZUxpc3R9IGZpbGVzIC0gQW4gb3B0aW9uYWwgRmlsZUxpc3Qgb2YgZmlsZXMgdG8gdXBsb2FkLlxuICAgKi9cbiAgYXN5bmMgdXBsb2FkSXRlbXMoZmlsZXM/OiBGaWxlTGlzdCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghZmlsZXMpIHJldHVybjtcblxuICAgIC8vIHByZXZlbnQgZmlsZSBuYW1lcyB0byBoYXZlIFwiLFwiKGNvbW1hKVxuICAgIGlmIChBcnJheS5mcm9tKGZpbGVzKS5zb21lKChmaWxlKSA9PiBmaWxlLm5hbWUuaW5jbHVkZXMoJywnKSkpIHtcbiAgICAgIHRoaXMuY0xvZy53YXJuKGBGaWxlIG5hbWVzIGNhbm5vdCBpbmNsdWRlIGEgXCIsXCIoY29tbWEpYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdXBsb2FkZWRGaWxlczogVXBsb2FkUmVzdWx0W10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmaWxlID0gZmlsZXNbaV07XG4gICAgICBjb25zdCBmaWxlUmVmID0gdGhpcy5zdG9yYWdlU2VydmljZVxuICAgICAgICAuZ2V0UmVmKGAke3RoaXMuY3VycmVudFBhdGh9LyR7ZmlsZS5uYW1lfWApO1xuICAgICAgYXdhaXQgdGhpcy5zdG9yYWdlU2VydmljZS51cGxvYWRGaWxlKGZpbGVSZWYsIGZpbGUpXG4gICAgICAgIC50aGVuKChzbmFwc2hvdCkgPT4gdXBsb2FkZWRGaWxlcy5wdXNoKHNuYXBzaG90KSlcbiAgICAgICAgLmNhdGNoKChlcnJvcjogRmlyZWJhc2VFcnJvcikgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVVwbG9hZEVycm9yKGVycm9yLCBmaWxlLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXVwbG9hZGVkRmlsZXMubGVuZ3RoKSByZXR1cm47XG5cbiAgICB0aGlzLnJlbG9hZCh0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlbiAqL1xuICAgIHRoaXMuY0xvZy5pbmZvKGBVcGxvYWRlZCAke3VwbG9hZGVkRmlsZXMubGVuZ3RofSAke3VwbG9hZGVkRmlsZXMubGVuZ3RoID09PSAxID8gJ2ZpbGUnIDogJ2ZpbGVzJ31gLCB1cGxvYWRlZEZpbGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBmaWxlIGlucHV0IGNoYW5nZS4gVHJpZ2dlcnMgdGhlIHVwbG9hZCBwcm9jZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSAkZXZlbnQgLSBUaGUgZmlsZSBpbnB1dCBjaGFuZ2UgZXZlbnQuXG4gICAqL1xuICBhc3luYyBvbkZpbGVzU2VsZWN0KCRldmVudDogRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBmaWxlczogRmlsZUxpc3QgPSAoPEhUTUxJbnB1dEVsZW1lbnQ+JGV2ZW50LnRhcmdldCkuZmlsZXMgYXMgRmlsZUxpc3Q7XG4gICAgYXdhaXQgdGhpcy51cGxvYWRJdGVtcyhmaWxlcyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBsb2dnaW5nIG9mIGVycm9ycyBkdXJpbmcgdGhlIGZpbGUgdXBsb2FkIHByb2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RmlyZWJhc2VFcnJvcn0gZXJyb3IgLSBUaGUgRmlyZWJhc2UgZXJyb3Igb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0aGF0IGZhaWxlZCB0byB1cGxvYWQuXG4gICAqL1xuICBoYW5kbGVVcGxvYWRFcnJvcihlcnJvcjogRmlyZWJhc2VFcnJvciwgZmlsZW5hbWU6IHN0cmluZykge1xuICAgIHRoaXMuY0xvZy5lcnJvcihcbiAgICAgIGVycm9yLmNvZGUgPT09ICdzdG9yYWdlL3VuYXV0aG9yaXplZCcgP1xuICAgICAgICAnWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gdXBsb2FkJyA6XG4gICAgICAgIGBFcnJvciB1cGxvYWRpbmcgZmlsZTogJyR7ZmlsZW5hbWV9J2AsXG4gICAgICBlcnJvcixcbiAgICApO1xuICB9XG59XG4iLCJAaWYgKGl0ZW1zJCB8IGFzeW5jOyBhcyBpdGVtcykge1xuICA8ZGl2IGNsYXNzPVwiY2FyZFwiPlxuICAgIDxpbnB1dCAjaW5wdXRVcGxvYWQgbXVsdGlwbGUgY2xhc3M9XCJpbnB1dFVwbG9hZFwiXG4gICAgICAgICAgIHR5cGU9XCJmaWxlXCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgIChjaGFuZ2UpPVwib25GaWxlc1NlbGVjdCgkZXZlbnQpXCIgLz5cbiAgICA8IS0tIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvdGVtcGxhdGUvbm8tY2FsbC1leHByZXNzaW9uIC0tPlxuICAgIEBpZiAoc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgPGhlYWRlciBjbGFzcz1cImhlYWRlclwiPlxuICAgICAgICA8IS0tIENydW1icyAtLT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJjcnVtYnNcIj5cbiAgICAgICAgICA8YnV0dG9uIG1hdC1pY29uLWJ1dHRvbiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJjdXJyZW50UGF0aD09PXJvb3RTdG9yYWdlUGF0aFwiXG4gICAgICAgICAgICAgICAgICAoY2xpY2spPVwic2V0U3RvcmFnZVBhdGgocm9vdFN0b3JhZ2VQYXRoKVwiPlxuICAgICAgICAgICAgPG1hdC1pY29uIGZvbnRJY29uPVwiaG9tZVwiIC8+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPCEtLSBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L3RlbXBsYXRlL25vLWNhbGwtZXhwcmVzc2lvbiAtLT5cbiAgICAgICAgICBAZm9yIChjcnVtYiBvZiBjdXJyZW50UGF0aC5zcGxpdCgnLycpOyB0cmFjayBjcnVtYjtsZXQgaT0kaW5kZXg7IGxldCBsYXN0PSRsYXN0KSB7XG4gICAgICAgICAgICBAaWYgKGNydW1iICE9PSByb290U3RvcmFnZVBhdGgpIHtcbiAgICAgICAgICAgICAgQGlmIChjdXJyZW50UGF0aCE9PXJvb3RTdG9yYWdlUGF0aCkge1xuICAgICAgICAgICAgICAgIDxtYXQtaWNvbiBjbGFzcz1cIm92ZXJmbG93LXZpc2libGVcIiBmb250SWNvbj1cImNoZXZyb25fcmlnaHRcIiAvPlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDxidXR0b24gbWF0LWJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgW2Rpc2FibGVkXT1cImxhc3RcIlxuICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJzZXRTdG9yYWdlUGF0aChnZXRDcnVtYlBhdGgoY3VycmVudFBhdGguc3BsaXQoJy8nKSwgaSkpXCI+XG4gICAgICAgICAgICAgIHt7Y3J1bWJ9fVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICA8L3NwYW4+XG5cbiAgICAgICAgPGJ1dHRvbiBtYXQtaWNvbi1idXR0b24gdHlwZT1cImJ1dHRvblwiIChjbGljayk9XCJyZWxvYWQoKVwiPlxuICAgICAgICAgIDxtYXQtaWNvbiBmb250SWNvbj1cInJlZnJlc2hcIiAvPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBtYXQtaWNvbi1idXR0b24gdHlwZT1cImJ1dHRvblwiIChjbGljayk9XCJjcmVhdGVOZXdGb2xkZXIoKVwiPlxuICAgICAgICAgIDxtYXQtaWNvbiBmb250SWNvbj1cImNyZWF0ZV9uZXdfZm9sZGVyXCIgLz5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPGJ1dHRvbiBtYXQtZmxhdC1idXR0b24gdHlwZT1cImJ1dHRvblwiIGNvbG9yPVwicHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgICAoY2xpY2spPVwiaW5wdXRVcGxvYWQuY2xpY2soKVwiPlVwbG9hZDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvaGVhZGVyPlxuICAgIH0gQGVsc2Uge1xuICAgICAgPGhlYWRlciBjbGFzcz1cImhlYWRlciBpdGVtcy1zZWxlY3RlZFwiPlxuICAgICAgICA8YnV0dG9uIG1hdC1pY29uLWJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgKGNsaWNrKT1cInNlbGVjdGlvbi5jbGVhcigpXCI+XG4gICAgICAgICAgPG1hdC1pY29uIGZvbnRJY29uPVwiY2xvc2VcIiAvPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPHNwYW4+e3tzZWxlY3Rpb24uc2VsZWN0ZWQubGVuZ3RofX0ge3tzZWxlY3Rpb24uc2VsZWN0ZWQubGVuZ3RoID09PSAxID8gJ2l0ZW0nIDogJ2l0ZW1zJ319PC9zcGFuPlxuICAgICAgICA8IS0tIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvdGVtcGxhdGUvbm8tY2FsbC1leHByZXNzaW9uIC0tPlxuICAgICAgICA8YnV0dG9uIG1hdC1yYWlzZWQtYnV0dG9uIHR5cGU9XCJidXR0b25cIiBjb2xvcj1cImFjY2VudFwiIFtkaXNhYmxlZF09XCJzZWxlY3Rpb25JbmNsdWRlc0ZvbGRlclwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cImRvd25sb2FkRmlsZXMoc2VsZWN0aW9uLnNlbGVjdGVkKVwiPkRvd25sb2FkIGZpbGVzPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gbWF0LXN0cm9rZWQtYnV0dG9uIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJkZWxldGVJdGVtcyhzZWxlY3Rpb24uc2VsZWN0ZWQpXCI+RGVsZXRlPC9idXR0b24+XG4gICAgICA8L2hlYWRlcj5cbiAgICB9XG5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgPGRpdiBjbGFzcz1cInRhYmxlLXNpZGViYXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhYmxlLXdyYXBwZXJcIiBbbmdDbGFzc109XCJ7J2dyaWQtY29sdW1uLWVuZC1zcGFuLTgnOiBzZWxlY3RlZEZpbGV9XCI+XG4gICAgICAgICAgPHRhYmxlIG1hdC10YWJsZSBbZGF0YVNvdXJjZV09XCJpdGVtc1wiPlxuICAgICAgICAgICAgPCEtLSBDaGVja2JveCBDb2x1bW4gLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj1cImNoZWNrYm94XCI+XG4gICAgICAgICAgICAgIDx0aCAqbWF0SGVhZGVyQ2VsbERlZiBtYXQtaGVhZGVyLWNlbGwgY2xhc3M9XCJjaGVja2JveC1jb2x1bW5cIj5cbiAgICAgICAgICAgICAgICA8IS0tIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvdGVtcGxhdGUvbm8tY2FsbC1leHByZXNzaW9uIC0tPlxuICAgICAgICAgICAgICAgIDxtYXQtY2hlY2tib3ggbmFtZT1cInNlbGVjdC1hbGxcIiBbY2hlY2tlZF09XCJhbGxJdGVtc1NlbGVjdGVkKGl0ZW1zKVwiIFtpbmRldGVybWluYXRlXT1cImFsbEl0ZW1zSW5kZXRlcm1pbmF0ZShpdGVtcylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cIml0ZW1zLmxlbmd0aCA9PT0gMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2hhbmdlKT1cInRvZ2dsZUFsbEl0ZW1zKCRldmVudC5jaGVja2VkLCBpdGVtcylcIiAvPlxuICAgICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgICA8dGQgKm1hdENlbGxEZWY9XCJsZXQgaXRlbVwiIG1hdC1jZWxsIGNsYXNzPVwiY2hlY2tib3gtY29sdW1uXCI+XG4gICAgICAgICAgICAgICAgPCEtLSBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L3RlbXBsYXRlL25vLWNhbGwtZXhwcmVzc2lvbiAtLT5cbiAgICAgICAgICAgICAgICA8bWF0LWNoZWNrYm94IFtjaGVja2VkXT1cInNlbGVjdGlvbi5pc1NlbGVjdGVkKGl0ZW0pXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCIkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNoYW5nZSk9XCJzZWxlY3Rpb24udG9nZ2xlKGl0ZW0pXCIgLz5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgICAgICA8IS0tIE5hbWUgQ29sdW1uIC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBtYXRDb2x1bW5EZWY9XCJuYW1lXCI+XG4gICAgICAgICAgICAgIDx0aCAqbWF0SGVhZGVyQ2VsbERlZiBtYXQtaGVhZGVyLWNlbGw+IE5hbWUgPC90aD5cbiAgICAgICAgICAgICAgPHRkICptYXRDZWxsRGVmPVwibGV0IGl0ZW1cIiBtYXQtY2VsbCBjbGFzcz1cIm5hbWUtY29sdW1uXCI+XG4gICAgICAgICAgICAgICAgPGFub24tc3RvcmFnZS1pdGVtLWljb24gW3R5cGVdPVwiaXRlbS50eXBlXCIgW2NvbnRlbnRUeXBlXT1cIml0ZW0uY29udGVudFR5cGVcIiAvPlxuICAgICAgICAgICAgICAgIDxzcGFuPnt7aXRlbS5uYW1lfX08L3NwYW4+XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgPCEtLSBTaXplIENvbHVtbiAtLT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgbWF0Q29sdW1uRGVmPVwic2l6ZVwiPlxuICAgICAgICAgICAgICA8dGggKm1hdEhlYWRlckNlbGxEZWYgbWF0LWhlYWRlci1jZWxsPiBTaXplIDwvdGg+XG4gICAgICAgICAgICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBpdGVtXCIgbWF0LWNlbGw+XG4gICAgICAgICAgICAgICAge3tpdGVtLnR5cGUgPT09ICdmb2xkZXInID8gJyZtZGFzaDsnIDogaXRlbS5zaXplIHwgZm9ybWF0Qnl0ZXN9fVxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgICAgIDwhLS0gVHlwZSBDb2x1bW4gLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj1cInR5cGVcIj5cbiAgICAgICAgICAgICAgPHRoICptYXRIZWFkZXJDZWxsRGVmIG1hdC1oZWFkZXItY2VsbD4gVHlwZSA8L3RoPlxuICAgICAgICAgICAgICA8dGQgKm1hdENlbGxEZWY9XCJsZXQgaXRlbVwiIG1hdC1jZWxsPlxuICAgICAgICAgICAgICAgIHt7aXRlbS50eXBlID09PSAnZm9sZGVyJyA/ICdGb2xkZXInIDogaXRlbS5jb250ZW50VHlwZX19XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgPCEtLSBMYXN0IE1vZGlmaWVkIENvbHVtbiAtLT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgbWF0Q29sdW1uRGVmPVwibGFzdE1vZGlmaWVkXCI+XG4gICAgICAgICAgICAgIDx0aCAqbWF0SGVhZGVyQ2VsbERlZiBtYXQtaGVhZGVyLWNlbGw+IExhc3QgTW9kaWZpZWQgPC90aD5cbiAgICAgICAgICAgICAgPHRkICptYXRDZWxsRGVmPVwibGV0IGl0ZW1cIiBtYXQtY2VsbD5cbiAgICAgICAgICAgICAgICB7e2l0ZW0udHlwZSA9PT0gJ2ZvbGRlcicgPyAnJm1kYXNoOycgOiBpdGVtLnVwZGF0ZWQgfCBkYXRlfX1cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgICAgICA8dHIgKm1hdEhlYWRlclJvd0RlZj1cInRhYmxlQ29sdW1uczsgc3RpY2t5OiB0cnVlXCIgbWF0LWhlYWRlci1yb3c+PC90cj5cbiAgICAgICAgICAgIDx0ciAqbWF0Um93RGVmPVwibGV0IGl0ZW07IGNvbHVtbnM6IHRhYmxlQ29sdW1ucztcIiBtYXQtcm93XG4gICAgICAgICAgICAgICAgW2NsYXNzLnNlbGVjdGVkXT1cInNlbGVjdGVkRmlsZSA9PT0gaXRlbVwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cInN0b3JhZ2VJdGVtU2VsZWN0ZWQoaXRlbSlcIj48L3RyPlxuICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIEBpZiAoc2VsZWN0ZWRGaWxlKSB7XG4gICAgICAgICAgPGFzaWRlIGNsYXNzPVwic2lkZWJhciBncmlkLWNvbHVtbi1lbmQtc3Bhbi00XCI+XG4gICAgICAgICAgICA8YW5vbi1zdG9yYWdlLWZpbGUtcHJldmlldyBbaXRlbV09XCJzZWxlY3RlZEZpbGVcIiAoX2Nsb3NlKT1cInNlbGVjdGVkRmlsZSA9IHVuZGVmaW5lZFwiIC8+XG4gICAgICAgICAgPC9hc2lkZT5cbiAgICAgICAgfVxuICAgICAgPC9kaXY+XG5cbiAgICAgIEBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICA8ZGl2IGFub25GaWxlRHJvcHpvbmUgY2xhc3M9XCJlbXB0eS1mb2xkZXJcIlxuICAgICAgICAgICAgIGhvdmVyQ2xhc3M9XCJob3ZlcmluZ1wiIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICAgKGNsaWNrKT1cImlucHV0VXBsb2FkLmNsaWNrKClcIlxuICAgICAgICAgICAgIChrZXl1cCk9XCJpbnB1dFVwbG9hZC5jbGljaygpXCJcbiAgICAgICAgICAgICAoZHJvcHBlZCk9XCJ1cGxvYWRJdGVtcygkZXZlbnQpXCI+XG4gICAgICAgICAgPGRpdj5ObyBmaWxlcyBmb3VuZDwvZGl2PlxuICAgICAgICAgIDxkaXY+RHJhZyBhbmQgZHJvcCBmaWxlcyB0byB1cGxvYWQ8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICB9XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxufSBAZWxzZSB7XG4gIDxhbm9uLWxvYWRpbmctb3ItZXJyb3IgW2Vycm9yXT1cImVycm9yXCIgLz5cbn1cbiJdfQ==