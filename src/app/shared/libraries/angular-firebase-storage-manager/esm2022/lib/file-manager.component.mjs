import { Component, Input } from '@angular/core';
import { NewFolderDialogComponent, } from './components/new-folder-dialog/new-folder-dialog.component';
import { SelectionModel } from '@angular/cdk/collections';
import { DeleteFilesDialogComponent, } from './components/delete-files-dialog/delete-files-dialog.component';
import { AsyncPipe, DatePipe, NgClass } from "@angular/common";
import { MatButtonModule } from "@angular/material/button";
import { MatIconModule } from "@angular/material/icon";
import { MatTableModule } from "@angular/material/table";
import { MatCheckboxModule } from "@angular/material/checkbox";
import { StorageItemIconComponent, } from "./components/storage-item-icon/storage-item-icon.component";
import { FormatBytesPipe } from "./pipes/format-bytes.pipe";
import { StorageFilePreviewComponent, } from "./components/storage-file-preview/storage-file-preview.component";
import { FileDropzoneDirective } from "./directives/file-dropzone.directive";
import { LoadingOrErrorComponent, } from "./components/loading-or-error/loading-or-error.component";
import { first } from "rxjs";
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/dialog";
import * as i2 from "./services/console-logger.service";
import * as i3 from "./services/firebase-storage.service";
import * as i4 from "@angular/material/button";
import * as i5 from "@angular/material/icon";
import * as i6 from "@angular/material/table";
import * as i7 from "@angular/material/checkbox";
export class FileManagerComponent {
    constructor(dialog, cLog, storageService) {
        this.dialog = dialog;
        this.cLog = cLog;
        this.storageService = storageService;
        /**
         * The columns to display in the file management table.
         */
        this.tableColumns = ['checkbox', 'name', 'size', 'type', 'lastModified'];
        /**
         * The current path within the storage system.
         */
        this.currentPath = '';
        /**
         * Used for managing multiple item selection within the file manager.
         */
        this.selection = new SelectionModel(true, []);
        /**
         * The root path within the storage system where the file manager operates.
         */
        this.rootStoragePath = '';
    }
    ngOnInit() {
        /** Sets the initial path within the storage system */
        this.currentPath = this.rootStoragePath;
        /** Fetches the initial storage items */
        this.items$ = this.getAllStorageItems(this.currentPath);
    }
    /**
     * Downloads the provided files by triggering download links.
     * @param {StorageItem[]} files - The files to download.
     */
    async downloadFiles(files) {
        await this.storageService.openAllFiles(files);
    }
    /**
     * Toggles the selection of all items in the file listing.
     *
     * @param {boolean} checked - Whether to select or deselect all items.
     * @param {StorageItem[]} items - The list of file items.
     */
    toggleAllItems(checked, items) {
        if (!checked) {
            this.selection.clear();
            return;
        }
        this.selection.select(...items);
    }
    /**
     * Checks if all items in the file listing are currently selected.
     *
     * @param {StorageItem[]} items - The list of file items.
     * @returns {boolean} True if all items are selected, false otherwise.
     */
    allItemsSelected(items) {
        return this.selection.selected.length === items.length &&
            this.selection.selected.length > 0;
    }
    /**
     * Checks if some, but not all, items in the file listing are selected.
     *
     * @param {StorageItem[]} items - The list of file items.
     * @returns {boolean} True if the selection state is indeterminate, false otherwise.
     */
    allItemsIndeterminate(items) {
        return this.selection.selected.length > 0 &&
            this.selection.selected.length < items.length;
    }
    /**
     * Event handler for when a storage item is selected. Updates the navigation if a folder
     * is selected, or sets the selected file if a file is selected.
     *
     * @param {StorageItem} item - The selected StorageItem.
     */
    storageItemSelected(item) {
        if (item.type === 'folder')
            this.setStoragePath(item.fullPath);
        else if (item.type === 'file')
            this.selectedFile = item;
    }
    /**
     * Checks if the current selection includes at least one folder.
     *
     * @returns {boolean} True if a folder is part of the selection, false otherwise.
     */
    get selectionIncludesFolder() {
        return this.selection.selected.some(item => item.type === 'folder');
    }
    /**
     * Opens a dialog to confirm deletion, and handles deleting selected items if confirmed.
     * Clears the selection and updates the file listing.
     *
     * @param {StorageItem[]} items - The items to delete.
     */
    deleteItems(items) {
        const dialogRef = this.dialog.open(DeleteFilesDialogComponent, {
            id: 'delete-files-dialog',
            minWidth: '250px'
        });
        dialogRef.afterClosed().pipe(first()).forEach((confirm) => {
            if (confirm) {
                this.storageService.deleteFiles(items)
                    .then(() => {
                    this.selection.clear();
                    if (items.some(item => item == this.selectedFile)) {
                        this.selectedFile = undefined;
                    }
                })
                    .then(() => this.reload(this.currentPath));
            }
        });
    }
    /**
     * Constructs a breadcrumb-style path string based on the current path history.
     * Used for navigation display.
     *
     * @param {string[]} pathArray - An array of path segments.
     * @param {number} index - The index up to which path segments should be included.
     * @returns {string} The constructed path string.
     */
    getCrumbPath(pathArray, index) {
        pathArray.length = index + 1;
        return pathArray.join('/');
    }
    /**
     * Updates the current path and fetches the new file listing.
     * Clears any existing selection.
     *
     * @param {string} path - The new storage path.
     */
    setStoragePath(path) {
        this.items$ = this.getAllStorageItems(path);
        this.currentPath = path;
        if (this.selection.hasValue())
            this.selection.clear();
    }
    /**
     * Retrieves and processes all items within a given storage path.
     *
     * @param {string} path - The storage path to list.
     * @returns {Promise<StorageItem[]>} A Promise resolving to the items,
     * or undefined in case of error.
     */
    async getAllStorageItems(path) {
        const storageRef = this.storageService.getRef(path);
        return this.storageService.listAll(storageRef)
            .then(async ({ items, prefixes }) => {
            const allItems = [
                ...prefixes.map(this.storageService.importFolder),
                ...(await Promise.all(items.map(this.storageService.importFile)))
            ];
            return allItems;
        })
            .catch((error) => {
            this.error = error;
            return new Promise(() => undefined);
        });
    }
    /**
     * Reloads the file and folder listing within the current or specified path.
     *
     * @param {string | null} path - Optional. The path to reload. If null,
     * the current path is used.
     */
    reload(path = null) {
        let pathRef;
        if (path)
            pathRef = this.storageService.getRef(path);
        else
            pathRef = this.storageService.getRef(this.currentPath);
        this.items$ = this.storageService.listAll(pathRef)
            .then(async ({ items, prefixes }) => [
            ...prefixes.map(this.storageService.importFolder),
            ...(await Promise.all(items.map(this.storageService.importFile)))
        ]);
    }
    /**
     * Opens a dialog to create a new folder and updates folder listing if successful.
     */
    createNewFolder() {
        const newFolderContract = {
            folderName: '',
            path: this.currentPath,
        };
        const dialogRef = this.dialog.open(NewFolderDialogComponent, {
            id: 'create-new-folder-dialog',
            width: '250px',
            data: newFolderContract,
        });
        dialogRef.afterClosed()
            .pipe(first())
            .forEach(({ folderName }) => {
            if (folderName) {
                const path = this.currentPath ?
                    `${this.currentPath}/${folderName}` : folderName;
                this.setStoragePath(path);
            }
        });
    }
    /**
     * Handles file upload logic, including validation and updating the
     * file listing upon successful upload. Logs errors if encountered.
     *
     * @param {FileList} files - An optional FileList of files to upload.
     */
    async uploadItems(files) {
        if (!files)
            return;
        // prevent file names to have ","(comma)
        if (Array.from(files).some(file => file.name.includes(","))) {
            this.cLog.warn(`File names cannot include a ","(comma)`);
            return;
        }
        const uploadedFiles = [];
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const fileRef = this.storageService.getRef(`${this.currentPath}/${file.name}`);
            await this.storageService.uploadFile(fileRef, file)
                .then((snapshot) => uploadedFiles.push(snapshot))
                .catch((error) => this.handleUploadError(error, file.name));
        }
        if (!uploadedFiles.length)
            return;
        this.reload(this.currentPath);
        /* eslint-disable-next-line max-len */
        this.cLog.info(`Uploaded ${uploadedFiles.length} ${uploadedFiles.length === 1 ? 'file' : 'files'}`, uploadedFiles);
    }
    /**
     * Event handler for file input change. Triggers the upload process.
     *
     * @param {Event} $event - The file input change event.
     */
    async onFilesSelect($event) {
        const files = $event.target.files;
        await this.uploadItems(files);
    }
    /**
     * Handles logging of errors during the file upload process.
     *
     * @param {FirebaseError} error - The Firebase error object.
     * @param {string} filename - The name of the file that failed to upload.
     */
    handleUploadError(error, filename) {
        this.cLog.error(error.code === 'storage/unauthorized' ?
            'You do not have permission to upload' :
            `Error uploading file: '${filename}'`, error);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: FileManagerComponent, deps: [{ token: i1.MatDialog }, { token: i2.ConsoleLoggerService }, { token: i3.FirebaseStorageService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.3.3", type: FileManagerComponent, isStandalone: true, selector: "anon-file-manager", inputs: { selection: "selection", selectedFile: "selectedFile", rootStoragePath: "rootStoragePath" }, ngImport: i0, template: "@if (items$ | async; as items) {\n  <div class=\"card\">\n    <input #inputUpload multiple class=\"inputUpload\"\n           type=\"file\" autocomplete=\"off\" tabindex=\"-1\"\n           (change)=\"onFilesSelect($event)\" />\n    <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n    @if (selection.isEmpty()) {\n      <header class=\"header\">\n        <!-- Crumbs -->\n        <span class=\"crumbs\">\n          <button mat-icon-button type=\"button\"\n                  [disabled]=\"currentPath===rootStoragePath\"\n                  (click)=\"setStoragePath(rootStoragePath)\">\n            <mat-icon fontIcon=\"home\" />\n          </button>\n          <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n          @for (crumb of currentPath.split('/'); track crumb;let i=$index; let last=$last) {\n            @if (crumb !== rootStoragePath) {\n              @if (currentPath!==rootStoragePath) {\n                <mat-icon class=\"overflow-visible\" fontIcon=\"chevron_right\" />\n              }\n              <button mat-button type=\"button\" [disabled]=\"last\"\n                      (click)=\"setStoragePath(getCrumbPath(currentPath.split('/'), i))\">\n              {{crumb}}\n            </button>\n            }\n          }\n        </span>\n\n        <button mat-icon-button type=\"button\" (click)=\"reload()\">\n          <mat-icon fontIcon=\"refresh\" />\n        </button>\n        <button mat-icon-button type=\"button\" (click)=\"createNewFolder()\">\n          <mat-icon fontIcon=\"create_new_folder\" />\n        </button>\n        <div>\n          <button mat-flat-button type=\"button\" color=\"primary\"\n                  (click)=\"inputUpload.click()\">Upload</button>\n        </div>\n      </header>\n    } @else {\n      <header class=\"header items-selected\">\n        <button mat-icon-button type=\"button\" (click)=\"selection.clear()\">\n          <mat-icon fontIcon=\"close\" />\n        </button>\n        <span>{{selection.selected.length}} {{selection.selected.length === 1 ? 'item' : 'items'}}</span>\n        <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n        <button mat-raised-button type=\"button\" color=\"accent\" [disabled]=\"selectionIncludesFolder\"\n                (click)=\"downloadFiles(selection.selected)\">Download files</button>\n        <button mat-stroked-button type=\"button\"\n                (click)=\"deleteItems(selection.selected)\">Delete</button>\n      </header>\n    }\n\n    <div class=\"content\">\n      <div class=\"table-sidebar\">\n        <div class=\"table-wrapper\" [ngClass]=\"{'grid-column-end-span-8': selectedFile}\">\n          <table mat-table [dataSource]=\"items\">\n            <!-- Checkbox Column -->\n            <ng-container matColumnDef=\"checkbox\">\n              <th *matHeaderCellDef mat-header-cell class=\"checkbox-column\">\n                <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n                <mat-checkbox name=\"select-all\" [checked]=\"allItemsSelected(items)\" [indeterminate]=\"allItemsIndeterminate(items)\"\n                              [disabled]=\"items.length === 0\"\n                              (change)=\"toggleAllItems($event.checked, items)\" />\n              </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"checkbox-column\">\n                <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n                <mat-checkbox [checked]=\"selection.isSelected(item)\"\n                              (click)=\"$event.stopPropagation()\"\n                              (change)=\"selection.toggle(item)\" />\n              </td>\n            </ng-container>\n\n            <!-- Name Column -->\n            <ng-container matColumnDef=\"name\">\n              <th *matHeaderCellDef mat-header-cell> Name </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"name-column\">\n                <anon-storage-item-icon [type]=\"item.type\" [contentType]=\"item.contentType\" />\n                <span>{{item.name}}</span>\n              </td>\n            </ng-container>\n\n            <!-- Size Column -->\n            <ng-container matColumnDef=\"size\">\n              <th *matHeaderCellDef mat-header-cell> Size </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.size | formatBytes}}\n              </td>\n            </ng-container>\n\n            <!-- Type Column -->\n            <ng-container matColumnDef=\"type\">\n              <th *matHeaderCellDef mat-header-cell> Type </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? 'Folder' : item.contentType}}\n              </td>\n            </ng-container>\n\n            <!-- Last Modified Column -->\n            <ng-container matColumnDef=\"lastModified\">\n              <th *matHeaderCellDef mat-header-cell> Last Modified </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.updated | date}}\n              </td>\n            </ng-container>\n\n            <tr *matHeaderRowDef=\"tableColumns; sticky: true\" mat-header-row></tr>\n            <tr *matRowDef=\"let item; columns: tableColumns;\" mat-row\n                [class.selected]=\"selectedFile === item\"\n                (click)=\"storageItemSelected(item)\"></tr>\n          </table>\n        </div>\n\n        @if (selectedFile) {\n          <aside class=\"sidebar grid-column-end-span-4\">\n            <anon-storage-file-preview [item]=\"selectedFile\" (_close)=\"selectedFile = undefined\" />\n          </aside>\n        }\n      </div>\n\n      @if (!items.length) {\n        <div anonFileDropzone class=\"empty-folder\"\n             hoverClass=\"hovering\" tabindex=\"0\"\n             (click)=\"inputUpload.click()\"\n             (keyup)=\"inputUpload.click()\"\n             (dropped)=\"uploadItems($event)\">\n          <div>No files found</div>\n          <div>Drag and drop files to upload</div>\n        </div>\n      }\n    </div>\n  </div>\n} @else {\n  <anon-loading-or-error [error]=\"error\" />\n}\n", styles: [".card{display:flex;flex-direction:column;border-radius:1rem;overflow:hidden;max-height:600px}header.header{height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 1rem}header.header.items-selected{justify-content:flex-start;gap:1rem}header.header.items-selected mat-icon{color:inherit}.crumbs{flex-grow:1;display:flex;align-items:center;width:100px;overflow-x:auto;overflow-y:hidden}.inputUpload{display:none}.content{display:flex;flex-direction:column;overflow:hidden}.table-sidebar{width:100%;display:grid;margin:0;grid-gap:1.5rem;grid-template-columns:repeat(12,minmax(0,1fr));overflow:hidden}.table-wrapper{grid-column-end:span 12;border-top-width:1px;border-top-style:solid;border-bottom-width:1px;border-bottom-style:solid;display:inline-flex;flex-direction:column;overflow:auto;border-radius:0 0 8px 8px;width:100%}table{min-width:100%;border:0;white-space:nowrap;border-collapse:collapse;table-layout:fixed}.checkbox-column{width:64px}.name-column{max-width:50vw;display:flex;align-items:center;height:auto;min-height:52px;overflow-wrap:break-word;white-space:pre;padding:.75rem 1rem .75rem 0}.name-column span{display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;overflow:hidden;width:100%}aside.sidebar{width:auto;margin:0}td{border:none!important}.mat-mdc-header-cell,.mat-mdc-cell{height:auto;min-height:52px;padding:0 1rem}.mat-mdc-row{cursor:pointer}.empty-folder{display:flex;flex-direction:column;justify-content:center;align-items:center;height:200px}.grid-column-end-span-4{grid-column-end:span 4}.grid-column-end-span-8{grid-column-end:span 8}.grid-column-end-span-12{grid-column-end:span 12}\n"], dependencies: [{ kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "ngmodule", type: MatButtonModule }, { kind: "component", type: i4.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", exportAs: ["matButton"] }, { kind: "component", type: i4.MatIconButton, selector: "button[mat-icon-button]", exportAs: ["matButton"] }, { kind: "ngmodule", type: MatIconModule }, { kind: "component", type: i5.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "ngmodule", type: MatTableModule }, { kind: "component", type: i6.MatTable, selector: "mat-table, table[mat-table]", exportAs: ["matTable"] }, { kind: "directive", type: i6.MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { kind: "directive", type: i6.MatHeaderRowDef, selector: "[matHeaderRowDef]", inputs: ["matHeaderRowDef", "matHeaderRowDefSticky"] }, { kind: "directive", type: i6.MatColumnDef, selector: "[matColumnDef]", inputs: ["matColumnDef"] }, { kind: "directive", type: i6.MatCellDef, selector: "[matCellDef]" }, { kind: "directive", type: i6.MatRowDef, selector: "[matRowDef]", inputs: ["matRowDefColumns", "matRowDefWhen"] }, { kind: "directive", type: i6.MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { kind: "directive", type: i6.MatCell, selector: "mat-cell, td[mat-cell]" }, { kind: "component", type: i6.MatHeaderRow, selector: "mat-header-row, tr[mat-header-row]", exportAs: ["matHeaderRow"] }, { kind: "component", type: i6.MatRow, selector: "mat-row, tr[mat-row]", exportAs: ["matRow"] }, { kind: "ngmodule", type: MatCheckboxModule }, { kind: "component", type: i7.MatCheckbox, selector: "mat-checkbox", inputs: ["aria-label", "aria-labelledby", "aria-describedby", "id", "required", "labelPosition", "name", "value", "disableRipple", "tabIndex", "color", "checked", "disabled", "indeterminate"], outputs: ["change", "indeterminateChange"], exportAs: ["matCheckbox"] }, { kind: "component", type: StorageItemIconComponent, selector: "anon-storage-item-icon", inputs: ["type", "contentType"] }, { kind: "pipe", type: FormatBytesPipe, name: "formatBytes" }, { kind: "pipe", type: DatePipe, name: "date" }, { kind: "component", type: StorageFilePreviewComponent, selector: "anon-storage-file-preview", inputs: ["item"], outputs: ["_close"] }, { kind: "directive", type: FileDropzoneDirective, selector: "[anonFileDropzone]", inputs: ["hoverClass"], outputs: ["dropped", "hovered"] }, { kind: "component", type: LoadingOrErrorComponent, selector: "anon-loading-or-error", inputs: ["error"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: FileManagerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'anon-file-manager', standalone: true, imports: [
                        AsyncPipe,
                        MatButtonModule,
                        MatIconModule,
                        MatTableModule,
                        MatCheckboxModule,
                        StorageItemIconComponent,
                        FormatBytesPipe,
                        DatePipe,
                        StorageFilePreviewComponent,
                        FileDropzoneDirective,
                        LoadingOrErrorComponent,
                        NgClass,
                    ], template: "@if (items$ | async; as items) {\n  <div class=\"card\">\n    <input #inputUpload multiple class=\"inputUpload\"\n           type=\"file\" autocomplete=\"off\" tabindex=\"-1\"\n           (change)=\"onFilesSelect($event)\" />\n    <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n    @if (selection.isEmpty()) {\n      <header class=\"header\">\n        <!-- Crumbs -->\n        <span class=\"crumbs\">\n          <button mat-icon-button type=\"button\"\n                  [disabled]=\"currentPath===rootStoragePath\"\n                  (click)=\"setStoragePath(rootStoragePath)\">\n            <mat-icon fontIcon=\"home\" />\n          </button>\n          <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n          @for (crumb of currentPath.split('/'); track crumb;let i=$index; let last=$last) {\n            @if (crumb !== rootStoragePath) {\n              @if (currentPath!==rootStoragePath) {\n                <mat-icon class=\"overflow-visible\" fontIcon=\"chevron_right\" />\n              }\n              <button mat-button type=\"button\" [disabled]=\"last\"\n                      (click)=\"setStoragePath(getCrumbPath(currentPath.split('/'), i))\">\n              {{crumb}}\n            </button>\n            }\n          }\n        </span>\n\n        <button mat-icon-button type=\"button\" (click)=\"reload()\">\n          <mat-icon fontIcon=\"refresh\" />\n        </button>\n        <button mat-icon-button type=\"button\" (click)=\"createNewFolder()\">\n          <mat-icon fontIcon=\"create_new_folder\" />\n        </button>\n        <div>\n          <button mat-flat-button type=\"button\" color=\"primary\"\n                  (click)=\"inputUpload.click()\">Upload</button>\n        </div>\n      </header>\n    } @else {\n      <header class=\"header items-selected\">\n        <button mat-icon-button type=\"button\" (click)=\"selection.clear()\">\n          <mat-icon fontIcon=\"close\" />\n        </button>\n        <span>{{selection.selected.length}} {{selection.selected.length === 1 ? 'item' : 'items'}}</span>\n        <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n        <button mat-raised-button type=\"button\" color=\"accent\" [disabled]=\"selectionIncludesFolder\"\n                (click)=\"downloadFiles(selection.selected)\">Download files</button>\n        <button mat-stroked-button type=\"button\"\n                (click)=\"deleteItems(selection.selected)\">Delete</button>\n      </header>\n    }\n\n    <div class=\"content\">\n      <div class=\"table-sidebar\">\n        <div class=\"table-wrapper\" [ngClass]=\"{'grid-column-end-span-8': selectedFile}\">\n          <table mat-table [dataSource]=\"items\">\n            <!-- Checkbox Column -->\n            <ng-container matColumnDef=\"checkbox\">\n              <th *matHeaderCellDef mat-header-cell class=\"checkbox-column\">\n                <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n                <mat-checkbox name=\"select-all\" [checked]=\"allItemsSelected(items)\" [indeterminate]=\"allItemsIndeterminate(items)\"\n                              [disabled]=\"items.length === 0\"\n                              (change)=\"toggleAllItems($event.checked, items)\" />\n              </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"checkbox-column\">\n                <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n                <mat-checkbox [checked]=\"selection.isSelected(item)\"\n                              (click)=\"$event.stopPropagation()\"\n                              (change)=\"selection.toggle(item)\" />\n              </td>\n            </ng-container>\n\n            <!-- Name Column -->\n            <ng-container matColumnDef=\"name\">\n              <th *matHeaderCellDef mat-header-cell> Name </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"name-column\">\n                <anon-storage-item-icon [type]=\"item.type\" [contentType]=\"item.contentType\" />\n                <span>{{item.name}}</span>\n              </td>\n            </ng-container>\n\n            <!-- Size Column -->\n            <ng-container matColumnDef=\"size\">\n              <th *matHeaderCellDef mat-header-cell> Size </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.size | formatBytes}}\n              </td>\n            </ng-container>\n\n            <!-- Type Column -->\n            <ng-container matColumnDef=\"type\">\n              <th *matHeaderCellDef mat-header-cell> Type </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? 'Folder' : item.contentType}}\n              </td>\n            </ng-container>\n\n            <!-- Last Modified Column -->\n            <ng-container matColumnDef=\"lastModified\">\n              <th *matHeaderCellDef mat-header-cell> Last Modified </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.updated | date}}\n              </td>\n            </ng-container>\n\n            <tr *matHeaderRowDef=\"tableColumns; sticky: true\" mat-header-row></tr>\n            <tr *matRowDef=\"let item; columns: tableColumns;\" mat-row\n                [class.selected]=\"selectedFile === item\"\n                (click)=\"storageItemSelected(item)\"></tr>\n          </table>\n        </div>\n\n        @if (selectedFile) {\n          <aside class=\"sidebar grid-column-end-span-4\">\n            <anon-storage-file-preview [item]=\"selectedFile\" (_close)=\"selectedFile = undefined\" />\n          </aside>\n        }\n      </div>\n\n      @if (!items.length) {\n        <div anonFileDropzone class=\"empty-folder\"\n             hoverClass=\"hovering\" tabindex=\"0\"\n             (click)=\"inputUpload.click()\"\n             (keyup)=\"inputUpload.click()\"\n             (dropped)=\"uploadItems($event)\">\n          <div>No files found</div>\n          <div>Drag and drop files to upload</div>\n        </div>\n      }\n    </div>\n  </div>\n} @else {\n  <anon-loading-or-error [error]=\"error\" />\n}\n", styles: [".card{display:flex;flex-direction:column;border-radius:1rem;overflow:hidden;max-height:600px}header.header{height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 1rem}header.header.items-selected{justify-content:flex-start;gap:1rem}header.header.items-selected mat-icon{color:inherit}.crumbs{flex-grow:1;display:flex;align-items:center;width:100px;overflow-x:auto;overflow-y:hidden}.inputUpload{display:none}.content{display:flex;flex-direction:column;overflow:hidden}.table-sidebar{width:100%;display:grid;margin:0;grid-gap:1.5rem;grid-template-columns:repeat(12,minmax(0,1fr));overflow:hidden}.table-wrapper{grid-column-end:span 12;border-top-width:1px;border-top-style:solid;border-bottom-width:1px;border-bottom-style:solid;display:inline-flex;flex-direction:column;overflow:auto;border-radius:0 0 8px 8px;width:100%}table{min-width:100%;border:0;white-space:nowrap;border-collapse:collapse;table-layout:fixed}.checkbox-column{width:64px}.name-column{max-width:50vw;display:flex;align-items:center;height:auto;min-height:52px;overflow-wrap:break-word;white-space:pre;padding:.75rem 1rem .75rem 0}.name-column span{display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;overflow:hidden;width:100%}aside.sidebar{width:auto;margin:0}td{border:none!important}.mat-mdc-header-cell,.mat-mdc-cell{height:auto;min-height:52px;padding:0 1rem}.mat-mdc-row{cursor:pointer}.empty-folder{display:flex;flex-direction:column;justify-content:center;align-items:center;height:200px}.grid-column-end-span-4{grid-column-end:span 4}.grid-column-end-span-8{grid-column-end:span 8}.grid-column-end-span-12{grid-column-end:span 12}\n"] }]
        }], ctorParameters: () => [{ type: i1.MatDialog }, { type: i2.ConsoleLoggerService }, { type: i3.FirebaseStorageService }], propDecorators: { selection: [{
                type: Input
            }], selectedFile: [{
                type: Input
            }], rootStoragePath: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItZmlyZWJhc2Utc3RvcmFnZS1tYW5hZ2VyL3NyYy9saWIvZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItZmlyZWJhc2Utc3RvcmFnZS1tYW5hZ2VyL3NyYy9saWIvZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFVLE1BQU0sZUFBZSxDQUFDO0FBS3pELE9BQU8sRUFFTCx3QkFBd0IsR0FDekIsTUFBTSw0REFBNEQsQ0FBQztBQUVwRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDMUQsT0FBTyxFQUNMLDBCQUEwQixHQUMzQixNQUFNLGdFQUFnRSxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9ELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDdkQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3pELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQy9ELE9BQU8sRUFDTCx3QkFBd0IsR0FDekIsTUFBTSw0REFBNEQsQ0FBQztBQUNwRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDNUQsT0FBTyxFQUNMLDJCQUEyQixHQUM1QixNQUFNLGtFQUFrRSxDQUFDO0FBQzFFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQzdFLE9BQU8sRUFDTCx1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RGQsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmlyZWJhc2VTdG9yYWdlU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvZmlyZWJhc2Utc3RvcmFnZS5zZXJ2aWNlJztcbmltcG9ydCB7IFN0b3JhZ2VSZWZlcmVuY2UsIFVwbG9hZFJlc3VsdCB9IGZyb20gJ0Bhbmd1bGFyL2ZpcmUvc3RvcmFnZSc7XG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGFuZ3VsYXIvZmlyZS9hcHAvZmlyZWJhc2UnO1xuaW1wb3J0IHsgTWF0RGlhbG9nIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvZGlhbG9nJztcbmltcG9ydCB7XG4gIE5ld0ZvbGRlckRpYWxvZ0Nsb3NlQ29udHJhY3QsXG4gIE5ld0ZvbGRlckRpYWxvZ0NvbXBvbmVudCwgTmV3Rm9sZGVyRGlhbG9nQ29udHJhY3QsXG59IGZyb20gJy4vY29tcG9uZW50cy9uZXctZm9sZGVyLWRpYWxvZy9uZXctZm9sZGVyLWRpYWxvZy5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3RvcmFnZUl0ZW0sIFN0b3JhZ2VGaWxlIH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFNlbGVjdGlvbk1vZGVsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zJztcbmltcG9ydCB7XG4gIERlbGV0ZUZpbGVzRGlhbG9nQ29tcG9uZW50LFxufSBmcm9tICcuL2NvbXBvbmVudHMvZGVsZXRlLWZpbGVzLWRpYWxvZy9kZWxldGUtZmlsZXMtZGlhbG9nLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBBc3luY1BpcGUsIERhdGVQaXBlLCBOZ0NsYXNzIH0gZnJvbSBcIkBhbmd1bGFyL2NvbW1vblwiO1xuaW1wb3J0IHsgTWF0QnV0dG9uTW9kdWxlIH0gZnJvbSBcIkBhbmd1bGFyL21hdGVyaWFsL2J1dHRvblwiO1xuaW1wb3J0IHsgTWF0SWNvbk1vZHVsZSB9IGZyb20gXCJAYW5ndWxhci9tYXRlcmlhbC9pY29uXCI7XG5pbXBvcnQgeyBNYXRUYWJsZU1vZHVsZSB9IGZyb20gXCJAYW5ndWxhci9tYXRlcmlhbC90YWJsZVwiO1xuaW1wb3J0IHsgTWF0Q2hlY2tib3hNb2R1bGUgfSBmcm9tIFwiQGFuZ3VsYXIvbWF0ZXJpYWwvY2hlY2tib3hcIjtcbmltcG9ydCB7XG4gIFN0b3JhZ2VJdGVtSWNvbkNvbXBvbmVudCxcbn0gZnJvbSBcIi4vY29tcG9uZW50cy9zdG9yYWdlLWl0ZW0taWNvbi9zdG9yYWdlLWl0ZW0taWNvbi5jb21wb25lbnRcIjtcbmltcG9ydCB7IEZvcm1hdEJ5dGVzUGlwZSB9IGZyb20gXCIuL3BpcGVzL2Zvcm1hdC1ieXRlcy5waXBlXCI7XG5pbXBvcnQge1xuICBTdG9yYWdlRmlsZVByZXZpZXdDb21wb25lbnQsXG59IGZyb20gXCIuL2NvbXBvbmVudHMvc3RvcmFnZS1maWxlLXByZXZpZXcvc3RvcmFnZS1maWxlLXByZXZpZXcuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBGaWxlRHJvcHpvbmVEaXJlY3RpdmUgfSBmcm9tIFwiLi9kaXJlY3RpdmVzL2ZpbGUtZHJvcHpvbmUuZGlyZWN0aXZlXCI7XG5pbXBvcnQge1xuICBMb2FkaW5nT3JFcnJvckNvbXBvbmVudCxcbn0gZnJvbSBcIi4vY29tcG9uZW50cy9sb2FkaW5nLW9yLWVycm9yL2xvYWRpbmctb3ItZXJyb3IuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBDb25zb2xlTG9nZ2VyU2VydmljZSB9IGZyb20gXCIuL3NlcnZpY2VzL2NvbnNvbGUtbG9nZ2VyLnNlcnZpY2VcIjtcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSBcInJ4anNcIjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYW5vbi1maWxlLW1hbmFnZXInLFxuICB0ZW1wbGF0ZVVybDogJy4vZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmw6ICcuL2ZpbGUtbWFuYWdlci5jb21wb25lbnQuc2NzcycsXG4gIHN0YW5kYWxvbmU6IHRydWUsXG4gIGltcG9ydHM6IFtcbiAgICBBc3luY1BpcGUsXG4gICAgTWF0QnV0dG9uTW9kdWxlLFxuICAgIE1hdEljb25Nb2R1bGUsXG4gICAgTWF0VGFibGVNb2R1bGUsXG4gICAgTWF0Q2hlY2tib3hNb2R1bGUsXG4gICAgU3RvcmFnZUl0ZW1JY29uQ29tcG9uZW50LFxuICAgIEZvcm1hdEJ5dGVzUGlwZSxcbiAgICBEYXRlUGlwZSxcbiAgICBTdG9yYWdlRmlsZVByZXZpZXdDb21wb25lbnQsXG4gICAgRmlsZURyb3B6b25lRGlyZWN0aXZlLFxuICAgIExvYWRpbmdPckVycm9yQ29tcG9uZW50LFxuICAgIE5nQ2xhc3MsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIEZpbGVNYW5hZ2VyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgLyoqXG4gICAqIFRoZSBjb2x1bW5zIHRvIGRpc3BsYXkgaW4gdGhlIGZpbGUgbWFuYWdlbWVudCB0YWJsZS5cbiAgICovXG4gIHRhYmxlQ29sdW1uczogc3RyaW5nW10gPSBbJ2NoZWNrYm94JywgJ25hbWUnLCAnc2l6ZScsICd0eXBlJywgJ2xhc3RNb2RpZmllZCddO1xuICAvKipcbiAgICogQSBQcm9taXNlIHJlc29sdmluZyB0byBhbiBhcnJheSBvZiBTdG9yYWdlSXRlbSBvYmplY3RzIHJlcHJlc2VudGluZ1xuICAgKiB0aGUgY3VycmVudCBkaXJlY3RvcnkgY29udGVudHMsIG9yIHVuZGVmaW5lZCBpZiBhbiBlcnJvciBvY2N1cnMuXG4gICAqL1xuICBpdGVtcyQ/OiBQcm9taXNlPFN0b3JhZ2VJdGVtW10+IHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgcGF0aCB3aXRoaW4gdGhlIHN0b3JhZ2Ugc3lzdGVtLlxuICAgKi9cbiAgY3VycmVudFBhdGggPSAnJztcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBwb3RlbnRpYWwgRmlyZWJhc2VFcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgZmlsZSBvcGVyYXRpb25zLlxuICAgKi9cbiAgZXJyb3I/OiBGaXJlYmFzZUVycm9yO1xuXG4gIC8qKlxuICAgKiBVc2VkIGZvciBtYW5hZ2luZyBtdWx0aXBsZSBpdGVtIHNlbGVjdGlvbiB3aXRoaW4gdGhlIGZpbGUgbWFuYWdlci5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb25Nb2RlbDxTdG9yYWdlSXRlbT4odHJ1ZSwgW10pO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGZpbGUgKGlmIGFueSkuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZWxlY3RlZEZpbGU6IFN0b3JhZ2VGaWxlIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgcm9vdCBwYXRoIHdpdGhpbiB0aGUgc3RvcmFnZSBzeXN0ZW0gd2hlcmUgdGhlIGZpbGUgbWFuYWdlciBvcGVyYXRlcy5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHJvb3RTdG9yYWdlUGF0aCA9ICcnO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZGlhbG9nOiBNYXREaWFsb2csXG4gICAgcHJpdmF0ZSBjTG9nOiBDb25zb2xlTG9nZ2VyU2VydmljZSxcbiAgICBwcml2YXRlIHN0b3JhZ2VTZXJ2aWNlOiBGaXJlYmFzZVN0b3JhZ2VTZXJ2aWNlLFxuICApIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgLyoqIFNldHMgdGhlIGluaXRpYWwgcGF0aCB3aXRoaW4gdGhlIHN0b3JhZ2Ugc3lzdGVtICovXG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IHRoaXMucm9vdFN0b3JhZ2VQYXRoO1xuICAgIC8qKiBGZXRjaGVzIHRoZSBpbml0aWFsIHN0b3JhZ2UgaXRlbXMgKi9cbiAgICB0aGlzLml0ZW1zJCA9IHRoaXMuZ2V0QWxsU3RvcmFnZUl0ZW1zKHRoaXMuY3VycmVudFBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERvd25sb2FkcyB0aGUgcHJvdmlkZWQgZmlsZXMgYnkgdHJpZ2dlcmluZyBkb3dubG9hZCBsaW5rcy5cbiAgICogQHBhcmFtIHtTdG9yYWdlSXRlbVtdfSBmaWxlcyAtIFRoZSBmaWxlcyB0byBkb3dubG9hZC5cbiAgICovXG4gIGFzeW5jIGRvd25sb2FkRmlsZXMoZmlsZXM6IFN0b3JhZ2VJdGVtW10pIHtcbiAgICBhd2FpdCB0aGlzLnN0b3JhZ2VTZXJ2aWNlLm9wZW5BbGxGaWxlcyhmaWxlcyk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIG9mIGFsbCBpdGVtcyBpbiB0aGUgZmlsZSBsaXN0aW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWQgLSBXaGV0aGVyIHRvIHNlbGVjdCBvciBkZXNlbGVjdCBhbGwgaXRlbXMuXG4gICAqIEBwYXJhbSB7U3RvcmFnZUl0ZW1bXX0gaXRlbXMgLSBUaGUgbGlzdCBvZiBmaWxlIGl0ZW1zLlxuICAgKi9cbiAgdG9nZ2xlQWxsSXRlbXMoY2hlY2tlZDogYm9vbGVhbiwgaXRlbXM6IFN0b3JhZ2VJdGVtW10pIHtcbiAgICBpZiAoIWNoZWNrZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdCguLi5pdGVtcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFsbCBpdGVtcyBpbiB0aGUgZmlsZSBsaXN0aW5nIGFyZSBjdXJyZW50bHkgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RvcmFnZUl0ZW1bXX0gaXRlbXMgLSBUaGUgbGlzdCBvZiBmaWxlIGl0ZW1zLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbGwgaXRlbXMgYXJlIHNlbGVjdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBhbGxJdGVtc1NlbGVjdGVkKGl0ZW1zOiBTdG9yYWdlSXRlbVtdKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGVkLmxlbmd0aCA9PT0gaXRlbXMubGVuZ3RoICYmXG4gICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RlZC5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBzb21lLCBidXQgbm90IGFsbCwgaXRlbXMgaW4gdGhlIGZpbGUgbGlzdGluZyBhcmUgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RvcmFnZUl0ZW1bXX0gaXRlbXMgLSBUaGUgbGlzdCBvZiBmaWxlIGl0ZW1zLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIHN0YXRlIGlzIGluZGV0ZXJtaW5hdGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGFsbEl0ZW1zSW5kZXRlcm1pbmF0ZShpdGVtczogU3RvcmFnZUl0ZW1bXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5zZWxlY3RlZC5sZW5ndGggPiAwICYmXG4gICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RlZC5sZW5ndGggPCBpdGVtcy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3Igd2hlbiBhIHN0b3JhZ2UgaXRlbSBpcyBzZWxlY3RlZC4gVXBkYXRlcyB0aGUgbmF2aWdhdGlvbiBpZiBhIGZvbGRlclxuICAgKiBpcyBzZWxlY3RlZCwgb3Igc2V0cyB0aGUgc2VsZWN0ZWQgZmlsZSBpZiBhIGZpbGUgaXMgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RvcmFnZUl0ZW19IGl0ZW0gLSBUaGUgc2VsZWN0ZWQgU3RvcmFnZUl0ZW0uXG4gICAqL1xuICBzdG9yYWdlSXRlbVNlbGVjdGVkKGl0ZW06IFN0b3JhZ2VJdGVtKSB7XG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2ZvbGRlcicpIHRoaXMuc2V0U3RvcmFnZVBhdGgoaXRlbS5mdWxsUGF0aClcbiAgICBlbHNlIGlmIChpdGVtLnR5cGUgPT09ICdmaWxlJykgdGhpcy5zZWxlY3RlZEZpbGUgPSBpdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaW5jbHVkZXMgYXQgbGVhc3Qgb25lIGZvbGRlci5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYSBmb2xkZXIgaXMgcGFydCBvZiB0aGUgc2VsZWN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBnZXQgc2VsZWN0aW9uSW5jbHVkZXNGb2xkZXIoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGVkLnNvbWUoaXRlbSA9PiBpdGVtLnR5cGUgPT09ICdmb2xkZXInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyBhIGRpYWxvZyB0byBjb25maXJtIGRlbGV0aW9uLCBhbmQgaGFuZGxlcyBkZWxldGluZyBzZWxlY3RlZCBpdGVtcyBpZiBjb25maXJtZWQuXG4gICAqIENsZWFycyB0aGUgc2VsZWN0aW9uIGFuZCB1cGRhdGVzIHRoZSBmaWxlIGxpc3RpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RvcmFnZUl0ZW1bXX0gaXRlbXMgLSBUaGUgaXRlbXMgdG8gZGVsZXRlLlxuICAgKi9cbiAgZGVsZXRlSXRlbXMoaXRlbXM6IFN0b3JhZ2VJdGVtW10pIHtcbiAgICBjb25zdCBkaWFsb2dSZWYgPSB0aGlzLmRpYWxvZy5vcGVuKERlbGV0ZUZpbGVzRGlhbG9nQ29tcG9uZW50LCB7XG4gICAgICBpZDogJ2RlbGV0ZS1maWxlcy1kaWFsb2cnLFxuICAgICAgbWluV2lkdGg6ICcyNTBweCdcbiAgICB9KTtcbiAgICBkaWFsb2dSZWYuYWZ0ZXJDbG9zZWQoKS5waXBlKGZpcnN0KCkpLmZvckVhY2goKGNvbmZpcm06IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKGNvbmZpcm0pIHtcbiAgICAgICAgICB0aGlzLnN0b3JhZ2VTZXJ2aWNlLmRlbGV0ZUZpbGVzKGl0ZW1zKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgICAgICAgICBpZiAoaXRlbXMuc29tZShpdGVtID0+IGl0ZW0gPT0gdGhpcy5zZWxlY3RlZEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEZpbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLnJlbG9hZCh0aGlzLmN1cnJlbnRQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBicmVhZGNydW1iLXN0eWxlIHBhdGggc3RyaW5nIGJhc2VkIG9uIHRoZSBjdXJyZW50IHBhdGggaGlzdG9yeS5cbiAgICogVXNlZCBmb3IgbmF2aWdhdGlvbiBkaXNwbGF5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoQXJyYXkgLSBBbiBhcnJheSBvZiBwYXRoIHNlZ21lbnRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggdXAgdG8gd2hpY2ggcGF0aCBzZWdtZW50cyBzaG91bGQgYmUgaW5jbHVkZWQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb25zdHJ1Y3RlZCBwYXRoIHN0cmluZy5cbiAgICovXG4gIGdldENydW1iUGF0aChwYXRoQXJyYXk6IHN0cmluZ1tdLCBpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBwYXRoQXJyYXkubGVuZ3RoID0gaW5kZXggKyAxO1xuICAgIHJldHVybiBwYXRoQXJyYXkuam9pbignLycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgcGF0aCBhbmQgZmV0Y2hlcyB0aGUgbmV3IGZpbGUgbGlzdGluZy5cbiAgICogQ2xlYXJzIGFueSBleGlzdGluZyBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIG5ldyBzdG9yYWdlIHBhdGguXG4gICAqL1xuICBzZXRTdG9yYWdlUGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgICB0aGlzLml0ZW1zJCA9IHRoaXMuZ2V0QWxsU3RvcmFnZUl0ZW1zKHBhdGgpO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBwYXRoO1xuICAgIGlmICh0aGlzLnNlbGVjdGlvbi5oYXNWYWx1ZSgpKSB0aGlzLnNlbGVjdGlvbi5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbmQgcHJvY2Vzc2VzIGFsbCBpdGVtcyB3aXRoaW4gYSBnaXZlbiBzdG9yYWdlIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHN0b3JhZ2UgcGF0aCB0byBsaXN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdG9yYWdlSXRlbVtdPn0gQSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgaXRlbXMsXG4gICAqIG9yIHVuZGVmaW5lZCBpbiBjYXNlIG9mIGVycm9yLlxuICAgKi9cbiAgYXN5bmMgZ2V0QWxsU3RvcmFnZUl0ZW1zKHBhdGg6IHN0cmluZyk6IFByb21pc2U8U3RvcmFnZUl0ZW1bXT4ge1xuICAgIGNvbnN0IHN0b3JhZ2VSZWY6IFN0b3JhZ2VSZWZlcmVuY2UgPSB0aGlzLnN0b3JhZ2VTZXJ2aWNlLmdldFJlZihwYXRoKTtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlU2VydmljZS5saXN0QWxsKHN0b3JhZ2VSZWYpXG4gICAgICAudGhlbihhc3luYyAoe2l0ZW1zLCBwcmVmaXhlc30pID0+IHtcbiAgICAgICAgY29uc3QgYWxsSXRlbXM6IFN0b3JhZ2VJdGVtW10gPSBbXG4gICAgICAgICAgLi4ucHJlZml4ZXMubWFwKHRoaXMuc3RvcmFnZVNlcnZpY2UuaW1wb3J0Rm9sZGVyKSxcbiAgICAgICAgICAuLi4oYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKHRoaXMuc3RvcmFnZVNlcnZpY2UuaW1wb3J0RmlsZSkpKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gYWxsSXRlbXM7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcjogRmlyZWJhc2VFcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxvYWRzIHRoZSBmaWxlIGFuZCBmb2xkZXIgbGlzdGluZyB3aXRoaW4gdGhlIGN1cnJlbnQgb3Igc3BlY2lmaWVkIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gcGF0aCAtIE9wdGlvbmFsLiBUaGUgcGF0aCB0byByZWxvYWQuIElmIG51bGwsXG4gICAqIHRoZSBjdXJyZW50IHBhdGggaXMgdXNlZC5cbiAgICovXG4gIHJlbG9hZChwYXRoOiBzdHJpbmcgfCBudWxsID0gbnVsbCkge1xuICAgIGxldCBwYXRoUmVmOiBTdG9yYWdlUmVmZXJlbmNlO1xuICAgIGlmIChwYXRoKSBwYXRoUmVmID0gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRSZWYocGF0aCk7XG4gICAgZWxzZSBwYXRoUmVmID0gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRSZWYodGhpcy5jdXJyZW50UGF0aCk7XG5cbiAgICB0aGlzLml0ZW1zJCA9IHRoaXMuc3RvcmFnZVNlcnZpY2UubGlzdEFsbChwYXRoUmVmKVxuICAgICAgLnRoZW4oYXN5bmMgKHtpdGVtcywgcHJlZml4ZXN9KSA9PiBbXG4gICAgICAgIC4uLnByZWZpeGVzLm1hcCh0aGlzLnN0b3JhZ2VTZXJ2aWNlLmltcG9ydEZvbGRlciksXG4gICAgICAgIC4uLihhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAodGhpcy5zdG9yYWdlU2VydmljZS5pbXBvcnRGaWxlKSkpXG4gICAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyBhIGRpYWxvZyB0byBjcmVhdGUgYSBuZXcgZm9sZGVyIGFuZCB1cGRhdGVzIGZvbGRlciBsaXN0aW5nIGlmIHN1Y2Nlc3NmdWwuXG4gICAqL1xuICBjcmVhdGVOZXdGb2xkZXIoKSB7XG4gICAgY29uc3QgbmV3Rm9sZGVyQ29udHJhY3Q6IE5ld0ZvbGRlckRpYWxvZ0NvbnRyYWN0ID0ge1xuICAgICAgZm9sZGVyTmFtZTogJycsXG4gICAgICBwYXRoOiB0aGlzLmN1cnJlbnRQYXRoLFxuICAgIH07XG4gICAgY29uc3QgZGlhbG9nUmVmID0gdGhpcy5kaWFsb2cub3BlbihOZXdGb2xkZXJEaWFsb2dDb21wb25lbnQsIHtcbiAgICAgIGlkOiAnY3JlYXRlLW5ldy1mb2xkZXItZGlhbG9nJyxcbiAgICAgIHdpZHRoOiAnMjUwcHgnLFxuICAgICAgZGF0YTogbmV3Rm9sZGVyQ29udHJhY3QsXG4gICAgfSk7XG4gICAgZGlhbG9nUmVmLmFmdGVyQ2xvc2VkKClcbiAgICAgIC5waXBlKGZpcnN0KCkpXG4gICAgICAuZm9yRWFjaCgoeyBmb2xkZXJOYW1lIH06IE5ld0ZvbGRlckRpYWxvZ0Nsb3NlQ29udHJhY3QpID0+IHtcblxuICAgICAgICBpZiAoZm9sZGVyTmFtZSkge1xuICAgICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmN1cnJlbnRQYXRoID9cbiAgICAgICAgICAgIGAke3RoaXMuY3VycmVudFBhdGh9LyR7Zm9sZGVyTmFtZX1gIDogZm9sZGVyTmFtZTtcbiAgICAgICAgICB0aGlzLnNldFN0b3JhZ2VQYXRoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGZpbGUgdXBsb2FkIGxvZ2ljLCBpbmNsdWRpbmcgdmFsaWRhdGlvbiBhbmQgdXBkYXRpbmcgdGhlXG4gICAqIGZpbGUgbGlzdGluZyB1cG9uIHN1Y2Nlc3NmdWwgdXBsb2FkLiBMb2dzIGVycm9ycyBpZiBlbmNvdW50ZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGaWxlTGlzdH0gZmlsZXMgLSBBbiBvcHRpb25hbCBGaWxlTGlzdCBvZiBmaWxlcyB0byB1cGxvYWQuXG4gICAqL1xuICBhc3luYyB1cGxvYWRJdGVtcyhmaWxlcz86IEZpbGVMaXN0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFmaWxlcykgcmV0dXJuO1xuXG4gICAgLy8gcHJldmVudCBmaWxlIG5hbWVzIHRvIGhhdmUgXCIsXCIoY29tbWEpXG4gICAgaWYgKEFycmF5LmZyb20oZmlsZXMpLnNvbWUoZmlsZSA9PiBmaWxlLm5hbWUuaW5jbHVkZXMoXCIsXCIpKSkge1xuICAgICAgdGhpcy5jTG9nLndhcm4oYEZpbGUgbmFtZXMgY2Fubm90IGluY2x1ZGUgYSBcIixcIihjb21tYSlgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB1cGxvYWRlZEZpbGVzOiBVcGxvYWRSZXN1bHRbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZpbGUgPSBmaWxlc1tpXTtcbiAgICAgIGNvbnN0IGZpbGVSZWYgPSB0aGlzLnN0b3JhZ2VTZXJ2aWNlLmdldFJlZihgJHt0aGlzLmN1cnJlbnRQYXRofS8ke2ZpbGUubmFtZX1gKTtcbiAgICAgIGF3YWl0IHRoaXMuc3RvcmFnZVNlcnZpY2UudXBsb2FkRmlsZShmaWxlUmVmLCBmaWxlKVxuICAgICAgICAudGhlbigoc25hcHNob3QpID0+IHVwbG9hZGVkRmlsZXMucHVzaChzbmFwc2hvdCkpXG4gICAgICAgIC5jYXRjaCgoZXJyb3I6IEZpcmViYXNlRXJyb3IpID0+IHRoaXMuaGFuZGxlVXBsb2FkRXJyb3IoZXJyb3IsIGZpbGUubmFtZSkpO1xuICAgIH1cblxuICAgIGlmICghdXBsb2FkZWRGaWxlcy5sZW5ndGgpIHJldHVybjtcblxuICAgIHRoaXMucmVsb2FkKHRoaXMuY3VycmVudFBhdGgpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuICovXG4gICAgdGhpcy5jTG9nLmluZm8oYFVwbG9hZGVkICR7dXBsb2FkZWRGaWxlcy5sZW5ndGh9ICR7dXBsb2FkZWRGaWxlcy5sZW5ndGggPT09IDEgPyAnZmlsZScgOiAnZmlsZXMnfWAsIHVwbG9hZGVkRmlsZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGZpbGUgaW5wdXQgY2hhbmdlLiBUcmlnZ2VycyB0aGUgdXBsb2FkIHByb2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9ICRldmVudCAtIFRoZSBmaWxlIGlucHV0IGNoYW5nZSBldmVudC5cbiAgICovXG4gIGFzeW5jIG9uRmlsZXNTZWxlY3QoJGV2ZW50OiBFdmVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGZpbGVzOiBGaWxlTGlzdCA9ICg8SFRNTElucHV0RWxlbWVudD4kZXZlbnQudGFyZ2V0KS5maWxlcyBhcyBGaWxlTGlzdDtcbiAgICBhd2FpdCB0aGlzLnVwbG9hZEl0ZW1zKGZpbGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGxvZ2dpbmcgb2YgZXJyb3JzIGR1cmluZyB0aGUgZmlsZSB1cGxvYWQgcHJvY2Vzcy5cbiAgICpcbiAgICogQHBhcmFtIHtGaXJlYmFzZUVycm9yfSBlcnJvciAtIFRoZSBGaXJlYmFzZSBlcnJvciBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRoYXQgZmFpbGVkIHRvIHVwbG9hZC5cbiAgICovXG4gIGhhbmRsZVVwbG9hZEVycm9yKGVycm9yOiBGaXJlYmFzZUVycm9yLCBmaWxlbmFtZTogc3RyaW5nKSB7XG4gICAgdGhpcy5jTG9nLmVycm9yKFxuICAgICAgZXJyb3IuY29kZSA9PT0gJ3N0b3JhZ2UvdW5hdXRob3JpemVkJyA/XG4gICAgICAgICdZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byB1cGxvYWQnIDpcbiAgICAgICAgYEVycm9yIHVwbG9hZGluZyBmaWxlOiAnJHtmaWxlbmFtZX0nYCxcbiAgICAgIGVycm9yLFxuICAgICk7XG4gIH1cbn1cbiIsIkBpZiAoaXRlbXMkIHwgYXN5bmM7IGFzIGl0ZW1zKSB7XG4gIDxkaXYgY2xhc3M9XCJjYXJkXCI+XG4gICAgPGlucHV0ICNpbnB1dFVwbG9hZCBtdWx0aXBsZSBjbGFzcz1cImlucHV0VXBsb2FkXCJcbiAgICAgICAgICAgdHlwZT1cImZpbGVcIiBhdXRvY29tcGxldGU9XCJvZmZcIiB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgKGNoYW5nZSk9XCJvbkZpbGVzU2VsZWN0KCRldmVudClcIiAvPlxuICAgIDwhLS0gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC90ZW1wbGF0ZS9uby1jYWxsLWV4cHJlc3Npb24gLS0+XG4gICAgQGlmIChzZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICA8aGVhZGVyIGNsYXNzPVwiaGVhZGVyXCI+XG4gICAgICAgIDwhLS0gQ3J1bWJzIC0tPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImNydW1ic1wiPlxuICAgICAgICAgIDxidXR0b24gbWF0LWljb24tYnV0dG9uIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImN1cnJlbnRQYXRoPT09cm9vdFN0b3JhZ2VQYXRoXCJcbiAgICAgICAgICAgICAgICAgIChjbGljayk9XCJzZXRTdG9yYWdlUGF0aChyb290U3RvcmFnZVBhdGgpXCI+XG4gICAgICAgICAgICA8bWF0LWljb24gZm9udEljb249XCJob21lXCIgLz5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8IS0tIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvdGVtcGxhdGUvbm8tY2FsbC1leHByZXNzaW9uIC0tPlxuICAgICAgICAgIEBmb3IgKGNydW1iIG9mIGN1cnJlbnRQYXRoLnNwbGl0KCcvJyk7IHRyYWNrIGNydW1iO2xldCBpPSRpbmRleDsgbGV0IGxhc3Q9JGxhc3QpIHtcbiAgICAgICAgICAgIEBpZiAoY3J1bWIgIT09IHJvb3RTdG9yYWdlUGF0aCkge1xuICAgICAgICAgICAgICBAaWYgKGN1cnJlbnRQYXRoIT09cm9vdFN0b3JhZ2VQYXRoKSB7XG4gICAgICAgICAgICAgICAgPG1hdC1pY29uIGNsYXNzPVwib3ZlcmZsb3ctdmlzaWJsZVwiIGZvbnRJY29uPVwiY2hldnJvbl9yaWdodFwiIC8+XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgPGJ1dHRvbiBtYXQtYnV0dG9uIHR5cGU9XCJidXR0b25cIiBbZGlzYWJsZWRdPVwibGFzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInNldFN0b3JhZ2VQYXRoKGdldENydW1iUGF0aChjdXJyZW50UGF0aC5zcGxpdCgnLycpLCBpKSlcIj5cbiAgICAgICAgICAgICAge3tjcnVtYn19XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIDwvc3Bhbj5cblxuICAgICAgICA8YnV0dG9uIG1hdC1pY29uLWJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgKGNsaWNrKT1cInJlbG9hZCgpXCI+XG4gICAgICAgICAgPG1hdC1pY29uIGZvbnRJY29uPVwicmVmcmVzaFwiIC8+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG1hdC1pY29uLWJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgKGNsaWNrKT1cImNyZWF0ZU5ld0ZvbGRlcigpXCI+XG4gICAgICAgICAgPG1hdC1pY29uIGZvbnRJY29uPVwiY3JlYXRlX25ld19mb2xkZXJcIiAvPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8YnV0dG9uIG1hdC1mbGF0LWJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY29sb3I9XCJwcmltYXJ5XCJcbiAgICAgICAgICAgICAgICAgIChjbGljayk9XCJpbnB1dFVwbG9hZC5jbGljaygpXCI+VXBsb2FkPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9oZWFkZXI+XG4gICAgfSBAZWxzZSB7XG4gICAgICA8aGVhZGVyIGNsYXNzPVwiaGVhZGVyIGl0ZW1zLXNlbGVjdGVkXCI+XG4gICAgICAgIDxidXR0b24gbWF0LWljb24tYnV0dG9uIHR5cGU9XCJidXR0b25cIiAoY2xpY2spPVwic2VsZWN0aW9uLmNsZWFyKClcIj5cbiAgICAgICAgICA8bWF0LWljb24gZm9udEljb249XCJjbG9zZVwiIC8+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8c3Bhbj57e3NlbGVjdGlvbi5zZWxlY3RlZC5sZW5ndGh9fSB7e3NlbGVjdGlvbi5zZWxlY3RlZC5sZW5ndGggPT09IDEgPyAnaXRlbScgOiAnaXRlbXMnfX08L3NwYW4+XG4gICAgICAgIDwhLS0gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC90ZW1wbGF0ZS9uby1jYWxsLWV4cHJlc3Npb24gLS0+XG4gICAgICAgIDxidXR0b24gbWF0LXJhaXNlZC1idXR0b24gdHlwZT1cImJ1dHRvblwiIGNvbG9yPVwiYWNjZW50XCIgW2Rpc2FibGVkXT1cInNlbGVjdGlvbkluY2x1ZGVzRm9sZGVyXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwiZG93bmxvYWRGaWxlcyhzZWxlY3Rpb24uc2VsZWN0ZWQpXCI+RG93bmxvYWQgZmlsZXM8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBtYXQtc3Ryb2tlZC1idXR0b24gdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cImRlbGV0ZUl0ZW1zKHNlbGVjdGlvbi5zZWxlY3RlZClcIj5EZWxldGU8L2J1dHRvbj5cbiAgICAgIDwvaGVhZGVyPlxuICAgIH1cblxuICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwidGFibGUtc2lkZWJhclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFibGUtd3JhcHBlclwiIFtuZ0NsYXNzXT1cInsnZ3JpZC1jb2x1bW4tZW5kLXNwYW4tOCc6IHNlbGVjdGVkRmlsZX1cIj5cbiAgICAgICAgICA8dGFibGUgbWF0LXRhYmxlIFtkYXRhU291cmNlXT1cIml0ZW1zXCI+XG4gICAgICAgICAgICA8IS0tIENoZWNrYm94IENvbHVtbiAtLT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgbWF0Q29sdW1uRGVmPVwiY2hlY2tib3hcIj5cbiAgICAgICAgICAgICAgPHRoICptYXRIZWFkZXJDZWxsRGVmIG1hdC1oZWFkZXItY2VsbCBjbGFzcz1cImNoZWNrYm94LWNvbHVtblwiPlxuICAgICAgICAgICAgICAgIDwhLS0gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC90ZW1wbGF0ZS9uby1jYWxsLWV4cHJlc3Npb24gLS0+XG4gICAgICAgICAgICAgICAgPG1hdC1jaGVja2JveCBuYW1lPVwic2VsZWN0LWFsbFwiIFtjaGVja2VkXT1cImFsbEl0ZW1zU2VsZWN0ZWQoaXRlbXMpXCIgW2luZGV0ZXJtaW5hdGVdPVwiYWxsSXRlbXNJbmRldGVybWluYXRlKGl0ZW1zKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiaXRlbXMubGVuZ3RoID09PSAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGFuZ2UpPVwidG9nZ2xlQWxsSXRlbXMoJGV2ZW50LmNoZWNrZWQsIGl0ZW1zKVwiIC8+XG4gICAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBpdGVtXCIgbWF0LWNlbGwgY2xhc3M9XCJjaGVja2JveC1jb2x1bW5cIj5cbiAgICAgICAgICAgICAgICA8IS0tIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvdGVtcGxhdGUvbm8tY2FsbC1leHByZXNzaW9uIC0tPlxuICAgICAgICAgICAgICAgIDxtYXQtY2hlY2tib3ggW2NoZWNrZWRdPVwic2VsZWN0aW9uLmlzU2VsZWN0ZWQoaXRlbSlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cIiRldmVudC5zdG9wUHJvcGFnYXRpb24oKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2hhbmdlKT1cInNlbGVjdGlvbi50b2dnbGUoaXRlbSlcIiAvPlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgICAgIDwhLS0gTmFtZSBDb2x1bW4gLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj1cIm5hbWVcIj5cbiAgICAgICAgICAgICAgPHRoICptYXRIZWFkZXJDZWxsRGVmIG1hdC1oZWFkZXItY2VsbD4gTmFtZSA8L3RoPlxuICAgICAgICAgICAgICA8dGQgKm1hdENlbGxEZWY9XCJsZXQgaXRlbVwiIG1hdC1jZWxsIGNsYXNzPVwibmFtZS1jb2x1bW5cIj5cbiAgICAgICAgICAgICAgICA8YW5vbi1zdG9yYWdlLWl0ZW0taWNvbiBbdHlwZV09XCJpdGVtLnR5cGVcIiBbY29udGVudFR5cGVdPVwiaXRlbS5jb250ZW50VHlwZVwiIC8+XG4gICAgICAgICAgICAgICAgPHNwYW4+e3tpdGVtLm5hbWV9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgICAgICA8IS0tIFNpemUgQ29sdW1uIC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBtYXRDb2x1bW5EZWY9XCJzaXplXCI+XG4gICAgICAgICAgICAgIDx0aCAqbWF0SGVhZGVyQ2VsbERlZiBtYXQtaGVhZGVyLWNlbGw+IFNpemUgPC90aD5cbiAgICAgICAgICAgICAgPHRkICptYXRDZWxsRGVmPVwibGV0IGl0ZW1cIiBtYXQtY2VsbD5cbiAgICAgICAgICAgICAgICB7e2l0ZW0udHlwZSA9PT0gJ2ZvbGRlcicgPyAnJm1kYXNoOycgOiBpdGVtLnNpemUgfCBmb3JtYXRCeXRlc319XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgPCEtLSBUeXBlIENvbHVtbiAtLT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgbWF0Q29sdW1uRGVmPVwidHlwZVwiPlxuICAgICAgICAgICAgICA8dGggKm1hdEhlYWRlckNlbGxEZWYgbWF0LWhlYWRlci1jZWxsPiBUeXBlIDwvdGg+XG4gICAgICAgICAgICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBpdGVtXCIgbWF0LWNlbGw+XG4gICAgICAgICAgICAgICAge3tpdGVtLnR5cGUgPT09ICdmb2xkZXInID8gJ0ZvbGRlcicgOiBpdGVtLmNvbnRlbnRUeXBlfX1cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgICAgICA8IS0tIExhc3QgTW9kaWZpZWQgQ29sdW1uIC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBtYXRDb2x1bW5EZWY9XCJsYXN0TW9kaWZpZWRcIj5cbiAgICAgICAgICAgICAgPHRoICptYXRIZWFkZXJDZWxsRGVmIG1hdC1oZWFkZXItY2VsbD4gTGFzdCBNb2RpZmllZCA8L3RoPlxuICAgICAgICAgICAgICA8dGQgKm1hdENlbGxEZWY9XCJsZXQgaXRlbVwiIG1hdC1jZWxsPlxuICAgICAgICAgICAgICAgIHt7aXRlbS50eXBlID09PSAnZm9sZGVyJyA/ICcmbWRhc2g7JyA6IGl0ZW0udXBkYXRlZCB8IGRhdGV9fVxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgICAgIDx0ciAqbWF0SGVhZGVyUm93RGVmPVwidGFibGVDb2x1bW5zOyBzdGlja3k6IHRydWVcIiBtYXQtaGVhZGVyLXJvdz48L3RyPlxuICAgICAgICAgICAgPHRyICptYXRSb3dEZWY9XCJsZXQgaXRlbTsgY29sdW1uczogdGFibGVDb2x1bW5zO1wiIG1hdC1yb3dcbiAgICAgICAgICAgICAgICBbY2xhc3Muc2VsZWN0ZWRdPVwic2VsZWN0ZWRGaWxlID09PSBpdGVtXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwic3RvcmFnZUl0ZW1TZWxlY3RlZChpdGVtKVwiPjwvdHI+XG4gICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgQGlmIChzZWxlY3RlZEZpbGUpIHtcbiAgICAgICAgICA8YXNpZGUgY2xhc3M9XCJzaWRlYmFyIGdyaWQtY29sdW1uLWVuZC1zcGFuLTRcIj5cbiAgICAgICAgICAgIDxhbm9uLXN0b3JhZ2UtZmlsZS1wcmV2aWV3IFtpdGVtXT1cInNlbGVjdGVkRmlsZVwiIChfY2xvc2UpPVwic2VsZWN0ZWRGaWxlID0gdW5kZWZpbmVkXCIgLz5cbiAgICAgICAgICA8L2FzaWRlPlxuICAgICAgICB9XG4gICAgICA8L2Rpdj5cblxuICAgICAgQGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIDxkaXYgYW5vbkZpbGVEcm9wem9uZSBjbGFzcz1cImVtcHR5LWZvbGRlclwiXG4gICAgICAgICAgICAgaG92ZXJDbGFzcz1cImhvdmVyaW5nXCIgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAoY2xpY2spPVwiaW5wdXRVcGxvYWQuY2xpY2soKVwiXG4gICAgICAgICAgICAgKGtleXVwKT1cImlucHV0VXBsb2FkLmNsaWNrKClcIlxuICAgICAgICAgICAgIChkcm9wcGVkKT1cInVwbG9hZEl0ZW1zKCRldmVudClcIj5cbiAgICAgICAgICA8ZGl2Pk5vIGZpbGVzIGZvdW5kPC9kaXY+XG4gICAgICAgICAgPGRpdj5EcmFnIGFuZCBkcm9wIGZpbGVzIHRvIHVwbG9hZDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIH1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG59IEBlbHNlIHtcbiAgPGFub24tbG9hZGluZy1vci1lcnJvciBbZXJyb3JdPVwiZXJyb3JcIiAvPlxufVxuIl19