import { Component, effect, Input, output } from '@angular/core';
import { NewFolderDialogComponent, } from './components/new-folder-dialog/new-folder-dialog.component';
import { SelectionModel } from '@angular/cdk/collections';
import { DeleteFilesDialogComponent, } from './components/delete-files-dialog/delete-files-dialog.component';
import { AsyncPipe, DatePipe, NgClass } from '@angular/common';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTableModule } from '@angular/material/table';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { StorageItemIconComponent, } from './components/storage-item-icon/storage-item-icon.component';
import { FormatBytesPipe } from './pipes/format-bytes.pipe';
import { StorageFilePreviewComponent, } from './components/storage-file-preview/storage-file-preview.component';
import { FileDropzoneDirective } from './directives/file-dropzone.directive';
import { LoadingOrErrorComponent, } from './components/loading-or-error/loading-or-error.component';
import { first } from 'rxjs';
import { toSignal } from '@angular/core/rxjs-interop';
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/dialog";
import * as i2 from "./services/console-logger.service";
import * as i3 from "./services/firebase-storage.service";
import * as i4 from "@angular/material/button";
import * as i5 from "@angular/material/icon";
import * as i6 from "@angular/material/table";
import * as i7 from "@angular/material/checkbox";
export class FileManagerComponent {
    constructor(dialog, cLog, storageService) {
        this.dialog = dialog;
        this.cLog = cLog;
        this.storageService = storageService;
        /**
         * The columns to display in the file management table.
         */
        this.tableColumns = ['checkbox', 'name', 'size', 'type', 'lastModified'];
        /**
         * The current path within the storage system.
         */
        this.currentPath = '';
        /**
         * Used for managing multiple item selection within the file manager.
         */
        this.selection = new SelectionModel(true, []);
        /**
         * The root path within the storage system where the file manager operates.
         */
        this.rootStoragePath = '';
        this.selectionChangeSignal = toSignal(this.selection.changed);
        this.selectionChange = output();
        effect(() => {
            const selectionChange = this.selectionChangeSignal();
            this.selectionChange.emit(selectionChange?.source.selected || null);
        });
    }
    ngOnInit() {
        /** Sets the initial path within the storage system */
        this.currentPath = this.rootStoragePath;
        /** Fetches the initial storage items */
        this.items$ = this.getAllStorageItems(this.currentPath);
    }
    /**
     * Downloads the provided files by triggering download links.
     * @param {StorageItem[]} files - The files to download.
     */
    async downloadFiles(files) {
        await this.storageService.openAllFiles(files);
    }
    /**
     * Toggles the selection of all items in the file listing.
     *
     * @param {boolean} checked - Whether to select or deselect all items.
     * @param {StorageItem[]} items - The list of file items.
     */
    toggleAllItems(checked, items) {
        if (!checked) {
            this.selection.clear();
            return;
        }
        this.selection.select(...items);
    }
    /**
     * Checks if all items in the file listing are currently selected.
     *
     * @param {StorageItem[]} items - The list of file items.
     * @return {boolean} True if all items are selected, false otherwise.
     */
    allItemsSelected(items) {
        return this.selection.selected.length === items.length &&
            this.selection.selected.length > 0;
    }
    /**
     * Checks if some, but not all, items in the file listing are selected.
     *
     * @param {StorageItem[]} items - The list of file items.
     * @return {boolean} True if the selection state is indeterminate, false
     * otherwise.
     */
    allItemsIndeterminate(items) {
        return this.selection.selected.length > 0 &&
            this.selection.selected.length < items.length;
    }
    /**
     * Event handler for when a storage item is selected. Updates the navigation
     * if a folder is selected, or sets the selected file if a file is selected.
     *
     * @param {StorageItem} item - The selected StorageItem.
     */
    storageItemSelected(item) {
        if (item.type === 'folder')
            this.setStoragePath(item.fullPath);
        else if (item.type === 'file')
            this.selectedFile = item;
    }
    /**
     * Checks if the current selection includes at least one folder.
     *
     * @return {boolean} True if a folder is part of the selection, false
     * otherwise.
     */
    get selectionIncludesFolder() {
        return this.selection.selected.some((item) => item.type === 'folder');
    }
    /**
     * Opens a dialog to confirm deletion, and handles deleting selected items
     * if confirmed. Clears the selection and updates the file listing.
     *
     * @param {StorageItem[]} items - The items to delete.
     */
    deleteItems(items) {
        const dialogRef = this.dialog.open(DeleteFilesDialogComponent, {
            id: 'delete-files-dialog',
            minWidth: '250px',
        });
        dialogRef.afterClosed().pipe(first()).forEach((confirm) => {
            if (confirm) {
                this.storageService.deleteFiles(items)
                    .then(() => {
                    this.selection.clear();
                    if (items.some((item) => item == this.selectedFile)) {
                        this.selectedFile = undefined;
                    }
                })
                    .then(() => this.reload(this.currentPath));
            }
        });
    }
    /**
     * Constructs a breadcrumb-style path string based on the current path
     * history. Used for navigation display.
     *
     * @param {string[]} pathArray - An array of path segments.
     * @param {number} index - The index up to which path segments should be
     * included.
     * @return {string} The constructed path string.
     */
    getCrumbPath(pathArray, index) {
        pathArray.length = index + 1;
        return pathArray.join('/');
    }
    /**
     * Updates the current path and fetches the new file listing.
     * Clears any existing selection.
     *
     * @param {string} path - The new storage path.
     */
    setStoragePath(path) {
        this.items$ = this.getAllStorageItems(path);
        this.currentPath = path;
        if (this.selection.hasValue())
            this.selection.clear();
    }
    /**
     * Retrieves and processes all items within a given storage path.
     *
     * @param {string} path - The storage path to list.
     * @return {Promise<StorageItem[]>} A Promise resolving to the items,
     * or undefined in case of error.
     */
    async getAllStorageItems(path) {
        const storageRef = this.storageService.getRef(path);
        return this.storageService.listAll(storageRef)
            .then(async ({ items, prefixes }) => {
            const allItems = [
                ...prefixes.map(this.storageService.importFolder),
                ...(await Promise.all(items.map(this.storageService.importFile))),
            ];
            return allItems;
        })
            .catch((error) => {
            this.error = error;
            return new Promise(() => undefined);
        });
    }
    /**
     * Reloads the file and folder listing within the current or specified path.
     *
     * @param {string | null} path - Optional. The path to reload. If null,
     * the current path is used.
     */
    reload(path = null) {
        let pathRef;
        if (path)
            pathRef = this.storageService.getRef(path);
        else
            pathRef = this.storageService.getRef(this.currentPath);
        this.items$ = this.storageService.listAll(pathRef)
            .then(async ({ items, prefixes }) => [
            ...prefixes.map(this.storageService.importFolder),
            ...(await Promise.all(items.map(this.storageService.importFile))),
        ]);
    }
    /**
     * Opens a dialog to create a new folder and updates folder listing
     * if successful.
     */
    createNewFolder() {
        const newFolderContract = {
            folderName: '',
            path: this.currentPath,
        };
        const dialogRef = this.dialog.open(NewFolderDialogComponent, {
            id: 'create-new-folder-dialog',
            width: '250px',
            data: newFolderContract,
        });
        dialogRef.afterClosed()
            .pipe(first())
            .forEach((contract) => {
            if (contract.folderName) {
                const path = this.currentPath ?
                    `${this.currentPath}/${contract.folderName}` : contract.folderName;
                this.setStoragePath(path);
            }
        });
    }
    /**
     * Handles file upload logic, including validation and updating the
     * file listing upon successful upload. Logs errors if encountered.
     *
     * @param {FileList} files - An optional FileList of files to upload.
     */
    async uploadItems(files) {
        if (!files)
            return;
        // prevent file names to have ","(comma)
        if (Array.from(files).some((file) => file.name.includes(','))) {
            this.cLog.warn(`File names cannot include a ","(comma)`);
            return;
        }
        const uploadedFiles = [];
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const fileRef = this.storageService
                .getRef(`${this.currentPath}/${file.name}`);
            await this.storageService.uploadFile(fileRef, file)
                .then((snapshot) => uploadedFiles.push(snapshot))
                .catch((error) => {
                return this.handleUploadError(error, file.name);
            });
        }
        if (!uploadedFiles.length)
            return;
        this.reload(this.currentPath);
        /* eslint-disable-next-line max-len */
        this.cLog.info(`Uploaded ${uploadedFiles.length} ${uploadedFiles.length === 1 ? 'file' : 'files'}`, uploadedFiles);
    }
    /**
     * Event handler for file input change. Triggers the upload process.
     *
     * @param {Event} $event - The file input change event.
     */
    async onFilesSelect($event) {
        const files = $event.target.files;
        await this.uploadItems(files);
    }
    /**
     * Handles logging of errors during the file upload process.
     *
     * @param {FirebaseError} error - The Firebase error object.
     * @param {string} filename - The name of the file that failed to upload.
     */
    handleUploadError(error, filename) {
        this.cLog.error(error.code === 'storage/unauthorized' ?
            'You do not have permission to upload' :
            `Error uploading file: '${filename}'`, error);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: FileManagerComponent, deps: [{ token: i1.MatDialog }, { token: i2.ConsoleLoggerService }, { token: i3.FirebaseStorageService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.3.3", type: FileManagerComponent, isStandalone: true, selector: "anon-file-manager", inputs: { selection: "selection", selectedFile: "selectedFile", rootStoragePath: "rootStoragePath" }, outputs: { selectionChange: "selectionChange" }, ngImport: i0, template: "@if (items$ | async; as items) {\n  <div class=\"card\">\n    <input #inputUpload multiple class=\"inputUpload\"\n           type=\"file\" autocomplete=\"off\" tabindex=\"-1\"\n           (change)=\"onFilesSelect($event)\" />\n    <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n    @if (selection.isEmpty()) {\n      <header class=\"header\">\n        <!-- Crumbs -->\n        <span class=\"crumbs\">\n          <button mat-icon-button type=\"button\"\n                  [disabled]=\"currentPath===rootStoragePath\"\n                  (click)=\"setStoragePath(rootStoragePath)\">\n            <mat-icon fontIcon=\"home\" />\n          </button>\n          <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n          @for (crumb of currentPath.split('/'); track crumb;let i=$index; let last=$last) {\n            @if (crumb !== rootStoragePath) {\n              @if (currentPath!==rootStoragePath) {\n                <mat-icon class=\"overflow-visible\" fontIcon=\"chevron_right\" />\n              }\n              <button mat-button type=\"button\" [disabled]=\"last\"\n                      (click)=\"setStoragePath(getCrumbPath(currentPath.split('/'), i))\">\n              {{crumb}}\n            </button>\n            }\n          }\n        </span>\n\n        <button mat-icon-button type=\"button\" (click)=\"reload()\">\n          <mat-icon fontIcon=\"refresh\" />\n        </button>\n        <button mat-icon-button type=\"button\" (click)=\"createNewFolder()\">\n          <mat-icon fontIcon=\"create_new_folder\" />\n        </button>\n        <div>\n          <button mat-flat-button type=\"button\" color=\"primary\"\n                  (click)=\"inputUpload.click()\">Upload</button>\n        </div>\n      </header>\n    } @else {\n      <header class=\"header items-selected\">\n        <button mat-icon-button type=\"button\" (click)=\"selection.clear()\">\n          <mat-icon fontIcon=\"close\" />\n        </button>\n        <span>{{selection.selected.length}} {{selection.selected.length === 1 ? 'item' : 'items'}}</span>\n        <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n        <button mat-raised-button type=\"button\" color=\"accent\" [disabled]=\"selectionIncludesFolder\"\n                (click)=\"downloadFiles(selection.selected)\">Download files</button>\n        <button mat-stroked-button type=\"button\"\n                (click)=\"deleteItems(selection.selected)\">Delete</button>\n      </header>\n    }\n\n    <div class=\"content\">\n      <div class=\"table-sidebar\">\n        <div class=\"table-wrapper\" [ngClass]=\"{'grid-column-end-span-8': selectedFile}\">\n          <table mat-table [dataSource]=\"items\">\n            <!-- Checkbox Column -->\n            <ng-container matColumnDef=\"checkbox\">\n              <th *matHeaderCellDef mat-header-cell class=\"checkbox-column\">\n                <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n                <mat-checkbox name=\"select-all\" [checked]=\"allItemsSelected(items)\" [indeterminate]=\"allItemsIndeterminate(items)\"\n                              [disabled]=\"items.length === 0\"\n                              (change)=\"toggleAllItems($event.checked, items)\" />\n              </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"checkbox-column\">\n                <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n                <mat-checkbox [checked]=\"selection.isSelected(item)\"\n                              (click)=\"$event.stopPropagation()\"\n                              (change)=\"selection.toggle(item)\" />\n              </td>\n            </ng-container>\n\n            <!-- Name Column -->\n            <ng-container matColumnDef=\"name\">\n              <th *matHeaderCellDef mat-header-cell> Name </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"name-column\">\n                <anon-storage-item-icon [type]=\"item.type\" [contentType]=\"item.contentType\" />\n                <span>{{item.name}}</span>\n              </td>\n            </ng-container>\n\n            <!-- Size Column -->\n            <ng-container matColumnDef=\"size\">\n              <th *matHeaderCellDef mat-header-cell> Size </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.size | formatBytes}}\n              </td>\n            </ng-container>\n\n            <!-- Type Column -->\n            <ng-container matColumnDef=\"type\">\n              <th *matHeaderCellDef mat-header-cell> Type </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? 'Folder' : item.contentType}}\n              </td>\n            </ng-container>\n\n            <!-- Last Modified Column -->\n            <ng-container matColumnDef=\"lastModified\">\n              <th *matHeaderCellDef mat-header-cell> Last Modified </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.updated | date}}\n              </td>\n            </ng-container>\n\n            <tr *matHeaderRowDef=\"tableColumns; sticky: true\" mat-header-row></tr>\n            <tr *matRowDef=\"let item; columns: tableColumns;\" mat-row\n                [class.selected]=\"selectedFile === item\"\n                (click)=\"storageItemSelected(item)\"></tr>\n\n            <tr *matNoDataRow class=\"mat-row\">\n              <td class=\"mat-cell\" [attr.colspan]=\"tableColumns.length\">\n                <div anonFileDropzone class=\"empty-folder\"\n                     hoverClass=\"hovering\" tabindex=\"0\"\n                     (click)=\"inputUpload.click()\"\n                     (keyup)=\"inputUpload.click()\"\n                     (dropped)=\"uploadItems($event)\">\n                  <div>No files found</div>\n                  <div>Drag and drop files to upload</div>\n                </div>\n              </td>\n            </tr>\n          </table>\n        </div>\n\n        @if (selectedFile) {\n          <aside class=\"sidebar grid-column-end-span-4\">\n            <anon-storage-file-preview [item]=\"selectedFile\" (_close)=\"selectedFile = undefined\" />\n          </aside>\n        }\n      </div>\n    </div>\n  </div>\n} @else {\n  <anon-loading-or-error [error]=\"error\" />\n}\n", styles: [".card{display:flex;flex-direction:column;border-radius:1rem;overflow:hidden}header.header{height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 1rem}header.header.items-selected{justify-content:flex-start;gap:1rem}header.header.items-selected mat-icon{color:inherit}.crumbs{flex-grow:1;display:flex;align-items:center;width:100px;overflow-x:auto;overflow-y:hidden}.inputUpload{display:none}.content{display:flex;flex-direction:column;overflow:hidden}.table-sidebar{width:100%;display:grid;margin:0;grid-gap:1.5rem;grid-template-columns:repeat(12,minmax(0,1fr));overflow:hidden}.table-wrapper{grid-column-end:span 12;border-top-width:1px;border-top-style:solid;border-bottom-width:1px;border-bottom-style:solid;display:inline-flex;flex-direction:column;overflow:auto;border-radius:0 0 8px 8px;width:100%}table{min-width:100%;border:0;white-space:nowrap;border-collapse:collapse;table-layout:fixed}.checkbox-column{width:64px}.name-column{max-width:50vw;display:flex;align-items:center;height:auto;min-height:52px;overflow-wrap:break-word;white-space:pre;padding:.75rem 1rem .75rem 0}.name-column span{display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;overflow:hidden;width:100%}aside.sidebar{width:auto;margin:0}td{border:none!important}.mat-mdc-header-cell,.mat-mdc-cell{height:auto;min-height:52px;padding:0 1rem}.mat-mdc-row{cursor:pointer}.empty-folder{display:flex;flex-direction:column;justify-content:center;align-items:center;min-height:200px;height:100%}.grid-column-end-span-4{grid-column-end:span 4}.grid-column-end-span-8{grid-column-end:span 8}.grid-column-end-span-12{grid-column-end:span 12}\n"], dependencies: [{ kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "ngmodule", type: MatButtonModule }, { kind: "component", type: i4.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", exportAs: ["matButton"] }, { kind: "component", type: i4.MatIconButton, selector: "button[mat-icon-button]", exportAs: ["matButton"] }, { kind: "ngmodule", type: MatIconModule }, { kind: "component", type: i5.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "ngmodule", type: MatTableModule }, { kind: "component", type: i6.MatTable, selector: "mat-table, table[mat-table]", exportAs: ["matTable"] }, { kind: "directive", type: i6.MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { kind: "directive", type: i6.MatHeaderRowDef, selector: "[matHeaderRowDef]", inputs: ["matHeaderRowDef", "matHeaderRowDefSticky"] }, { kind: "directive", type: i6.MatColumnDef, selector: "[matColumnDef]", inputs: ["matColumnDef"] }, { kind: "directive", type: i6.MatCellDef, selector: "[matCellDef]" }, { kind: "directive", type: i6.MatRowDef, selector: "[matRowDef]", inputs: ["matRowDefColumns", "matRowDefWhen"] }, { kind: "directive", type: i6.MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { kind: "directive", type: i6.MatCell, selector: "mat-cell, td[mat-cell]" }, { kind: "component", type: i6.MatHeaderRow, selector: "mat-header-row, tr[mat-header-row]", exportAs: ["matHeaderRow"] }, { kind: "component", type: i6.MatRow, selector: "mat-row, tr[mat-row]", exportAs: ["matRow"] }, { kind: "directive", type: i6.MatNoDataRow, selector: "ng-template[matNoDataRow]" }, { kind: "ngmodule", type: MatCheckboxModule }, { kind: "component", type: i7.MatCheckbox, selector: "mat-checkbox", inputs: ["aria-label", "aria-labelledby", "aria-describedby", "id", "required", "labelPosition", "name", "value", "disableRipple", "tabIndex", "color", "checked", "disabled", "indeterminate"], outputs: ["change", "indeterminateChange"], exportAs: ["matCheckbox"] }, { kind: "component", type: StorageItemIconComponent, selector: "anon-storage-item-icon", inputs: ["type", "contentType"] }, { kind: "pipe", type: FormatBytesPipe, name: "formatBytes" }, { kind: "pipe", type: DatePipe, name: "date" }, { kind: "component", type: StorageFilePreviewComponent, selector: "anon-storage-file-preview", inputs: ["item"], outputs: ["_close"] }, { kind: "directive", type: FileDropzoneDirective, selector: "[anonFileDropzone]", inputs: ["hoverClass"], outputs: ["dropped", "hovered"] }, { kind: "component", type: LoadingOrErrorComponent, selector: "anon-loading-or-error", inputs: ["error"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: FileManagerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'anon-file-manager', standalone: true, imports: [
                        AsyncPipe,
                        MatButtonModule,
                        MatIconModule,
                        MatTableModule,
                        MatCheckboxModule,
                        StorageItemIconComponent,
                        FormatBytesPipe,
                        DatePipe,
                        StorageFilePreviewComponent,
                        FileDropzoneDirective,
                        LoadingOrErrorComponent,
                        NgClass,
                    ], template: "@if (items$ | async; as items) {\n  <div class=\"card\">\n    <input #inputUpload multiple class=\"inputUpload\"\n           type=\"file\" autocomplete=\"off\" tabindex=\"-1\"\n           (change)=\"onFilesSelect($event)\" />\n    <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n    @if (selection.isEmpty()) {\n      <header class=\"header\">\n        <!-- Crumbs -->\n        <span class=\"crumbs\">\n          <button mat-icon-button type=\"button\"\n                  [disabled]=\"currentPath===rootStoragePath\"\n                  (click)=\"setStoragePath(rootStoragePath)\">\n            <mat-icon fontIcon=\"home\" />\n          </button>\n          <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n          @for (crumb of currentPath.split('/'); track crumb;let i=$index; let last=$last) {\n            @if (crumb !== rootStoragePath) {\n              @if (currentPath!==rootStoragePath) {\n                <mat-icon class=\"overflow-visible\" fontIcon=\"chevron_right\" />\n              }\n              <button mat-button type=\"button\" [disabled]=\"last\"\n                      (click)=\"setStoragePath(getCrumbPath(currentPath.split('/'), i))\">\n              {{crumb}}\n            </button>\n            }\n          }\n        </span>\n\n        <button mat-icon-button type=\"button\" (click)=\"reload()\">\n          <mat-icon fontIcon=\"refresh\" />\n        </button>\n        <button mat-icon-button type=\"button\" (click)=\"createNewFolder()\">\n          <mat-icon fontIcon=\"create_new_folder\" />\n        </button>\n        <div>\n          <button mat-flat-button type=\"button\" color=\"primary\"\n                  (click)=\"inputUpload.click()\">Upload</button>\n        </div>\n      </header>\n    } @else {\n      <header class=\"header items-selected\">\n        <button mat-icon-button type=\"button\" (click)=\"selection.clear()\">\n          <mat-icon fontIcon=\"close\" />\n        </button>\n        <span>{{selection.selected.length}} {{selection.selected.length === 1 ? 'item' : 'items'}}</span>\n        <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n        <button mat-raised-button type=\"button\" color=\"accent\" [disabled]=\"selectionIncludesFolder\"\n                (click)=\"downloadFiles(selection.selected)\">Download files</button>\n        <button mat-stroked-button type=\"button\"\n                (click)=\"deleteItems(selection.selected)\">Delete</button>\n      </header>\n    }\n\n    <div class=\"content\">\n      <div class=\"table-sidebar\">\n        <div class=\"table-wrapper\" [ngClass]=\"{'grid-column-end-span-8': selectedFile}\">\n          <table mat-table [dataSource]=\"items\">\n            <!-- Checkbox Column -->\n            <ng-container matColumnDef=\"checkbox\">\n              <th *matHeaderCellDef mat-header-cell class=\"checkbox-column\">\n                <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n                <mat-checkbox name=\"select-all\" [checked]=\"allItemsSelected(items)\" [indeterminate]=\"allItemsIndeterminate(items)\"\n                              [disabled]=\"items.length === 0\"\n                              (change)=\"toggleAllItems($event.checked, items)\" />\n              </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"checkbox-column\">\n                <!-- eslint-disable-next-line @angular-eslint/template/no-call-expression -->\n                <mat-checkbox [checked]=\"selection.isSelected(item)\"\n                              (click)=\"$event.stopPropagation()\"\n                              (change)=\"selection.toggle(item)\" />\n              </td>\n            </ng-container>\n\n            <!-- Name Column -->\n            <ng-container matColumnDef=\"name\">\n              <th *matHeaderCellDef mat-header-cell> Name </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"name-column\">\n                <anon-storage-item-icon [type]=\"item.type\" [contentType]=\"item.contentType\" />\n                <span>{{item.name}}</span>\n              </td>\n            </ng-container>\n\n            <!-- Size Column -->\n            <ng-container matColumnDef=\"size\">\n              <th *matHeaderCellDef mat-header-cell> Size </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.size | formatBytes}}\n              </td>\n            </ng-container>\n\n            <!-- Type Column -->\n            <ng-container matColumnDef=\"type\">\n              <th *matHeaderCellDef mat-header-cell> Type </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? 'Folder' : item.contentType}}\n              </td>\n            </ng-container>\n\n            <!-- Last Modified Column -->\n            <ng-container matColumnDef=\"lastModified\">\n              <th *matHeaderCellDef mat-header-cell> Last Modified </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.updated | date}}\n              </td>\n            </ng-container>\n\n            <tr *matHeaderRowDef=\"tableColumns; sticky: true\" mat-header-row></tr>\n            <tr *matRowDef=\"let item; columns: tableColumns;\" mat-row\n                [class.selected]=\"selectedFile === item\"\n                (click)=\"storageItemSelected(item)\"></tr>\n\n            <tr *matNoDataRow class=\"mat-row\">\n              <td class=\"mat-cell\" [attr.colspan]=\"tableColumns.length\">\n                <div anonFileDropzone class=\"empty-folder\"\n                     hoverClass=\"hovering\" tabindex=\"0\"\n                     (click)=\"inputUpload.click()\"\n                     (keyup)=\"inputUpload.click()\"\n                     (dropped)=\"uploadItems($event)\">\n                  <div>No files found</div>\n                  <div>Drag and drop files to upload</div>\n                </div>\n              </td>\n            </tr>\n          </table>\n        </div>\n\n        @if (selectedFile) {\n          <aside class=\"sidebar grid-column-end-span-4\">\n            <anon-storage-file-preview [item]=\"selectedFile\" (_close)=\"selectedFile = undefined\" />\n          </aside>\n        }\n      </div>\n    </div>\n  </div>\n} @else {\n  <anon-loading-or-error [error]=\"error\" />\n}\n", styles: [".card{display:flex;flex-direction:column;border-radius:1rem;overflow:hidden}header.header{height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 1rem}header.header.items-selected{justify-content:flex-start;gap:1rem}header.header.items-selected mat-icon{color:inherit}.crumbs{flex-grow:1;display:flex;align-items:center;width:100px;overflow-x:auto;overflow-y:hidden}.inputUpload{display:none}.content{display:flex;flex-direction:column;overflow:hidden}.table-sidebar{width:100%;display:grid;margin:0;grid-gap:1.5rem;grid-template-columns:repeat(12,minmax(0,1fr));overflow:hidden}.table-wrapper{grid-column-end:span 12;border-top-width:1px;border-top-style:solid;border-bottom-width:1px;border-bottom-style:solid;display:inline-flex;flex-direction:column;overflow:auto;border-radius:0 0 8px 8px;width:100%}table{min-width:100%;border:0;white-space:nowrap;border-collapse:collapse;table-layout:fixed}.checkbox-column{width:64px}.name-column{max-width:50vw;display:flex;align-items:center;height:auto;min-height:52px;overflow-wrap:break-word;white-space:pre;padding:.75rem 1rem .75rem 0}.name-column span{display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;overflow:hidden;width:100%}aside.sidebar{width:auto;margin:0}td{border:none!important}.mat-mdc-header-cell,.mat-mdc-cell{height:auto;min-height:52px;padding:0 1rem}.mat-mdc-row{cursor:pointer}.empty-folder{display:flex;flex-direction:column;justify-content:center;align-items:center;min-height:200px;height:100%}.grid-column-end-span-4{grid-column-end:span 4}.grid-column-end-span-8{grid-column-end:span 8}.grid-column-end-span-12{grid-column-end:span 12}\n"] }]
        }], ctorParameters: () => [{ type: i1.MatDialog }, { type: i2.ConsoleLoggerService }, { type: i3.FirebaseStorageService }], propDecorators: { selection: [{
                type: Input
            }], selectedFile: [{
                type: Input
            }], rootStoragePath: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItZmlyZWJhc2Utc3RvcmFnZS1tYW5hZ2VyL3NyYy9saWIvZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItZmlyZWJhc2Utc3RvcmFnZS1tYW5hZ2VyL3NyYy9saWIvZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBVSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFLekUsT0FBTyxFQUVMLHdCQUF3QixHQUN6QixNQUFNLDREQUE0RCxDQUFDO0FBRXBFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUMxRCxPQUFPLEVBQ0wsMEJBQTBCLEdBQzNCLE1BQU0sZ0VBQWdFLENBQUM7QUFDeEUsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0QsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzNELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN2RCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDekQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDL0QsT0FBTyxFQUNMLHdCQUF3QixHQUN6QixNQUFNLDREQUE0RCxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM1RCxPQUFPLEVBQ0wsMkJBQTJCLEdBQzVCLE1BQU0sa0VBQWtFLENBQUM7QUFDMUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDN0UsT0FBTyxFQUNMLHVCQUF1QixHQUN4QixNQUFNLDBEQUEwRCxDQUFDO0FBRWxFLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDN0IsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLDRCQUE0QixDQUFDOzs7Ozs7Ozs7QUFzQnRELE1BQU0sT0FBTyxvQkFBb0I7SUF3Qy9CLFlBQ1UsTUFBaUIsRUFDakIsSUFBMEIsRUFDMUIsY0FBc0M7UUFGdEMsV0FBTSxHQUFOLE1BQU0sQ0FBVztRQUNqQixTQUFJLEdBQUosSUFBSSxDQUFzQjtRQUMxQixtQkFBYyxHQUFkLGNBQWMsQ0FBd0I7UUExQ2hEOztXQUVHO1FBQ0gsaUJBQVksR0FBYSxDQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxjQUFjLENBQUMsQ0FBQztRQU05RTs7V0FFRztRQUNILGdCQUFXLEdBQUcsRUFBRSxDQUFDO1FBTWpCOztXQUVHO1FBRUgsY0FBUyxHQUFHLElBQUksY0FBYyxDQUFjLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztRQVF0RDs7V0FFRztRQUVILG9CQUFlLEdBQUcsRUFBRSxDQUFDO1FBRXJCLDBCQUFxQixHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3pELG9CQUFlLEdBQUcsTUFBTSxFQUF3QixDQUFDO1FBTy9DLE1BQU0sQ0FBQyxHQUFHLEVBQUU7WUFDVixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztZQUNyRCxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsTUFBTSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsQ0FBQztRQUN0RSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxRQUFRO1FBQ04sc0RBQXNEO1FBQ3RELElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUN4Qyx3Q0FBd0M7UUFDeEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQW9CO1FBQ3RDLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsY0FBYyxDQUFDLE9BQWdCLEVBQUUsS0FBb0I7UUFDbkQsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUN2QixPQUFPO1FBQ1QsQ0FBQztRQUNELElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsZ0JBQWdCLENBQUMsS0FBb0I7UUFDbkMsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEtBQUssS0FBSyxDQUFDLE1BQU07WUFDcEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gscUJBQXFCLENBQUMsS0FBb0I7UUFDeEMsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQztZQUN2QyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztJQUNsRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxtQkFBbUIsQ0FBQyxJQUFpQjtRQUNuQyxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUTtZQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQzFELElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNO1lBQUUsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7SUFDMUQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsSUFBSSx1QkFBdUI7UUFDekIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsV0FBVyxDQUFDLEtBQW9CO1FBQzlCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDBCQUEwQixFQUFFO1lBQzdELEVBQUUsRUFBRSxxQkFBcUI7WUFDekIsUUFBUSxFQUFFLE9BQU87U0FDbEIsQ0FBQyxDQUFDO1FBQ0gsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQWdCLEVBQUUsRUFBRTtZQUMvRCxJQUFJLE9BQU8sRUFBRSxDQUFDO2dCQUNaLElBQUksQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQztxQkFDbkMsSUFBSSxDQUFDLEdBQUcsRUFBRTtvQkFDVCxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUN2QixJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQzt3QkFDcEQsSUFBSSxDQUFDLFlBQVksR0FBRyxTQUFTLENBQUM7b0JBQ2hDLENBQUM7Z0JBQ0gsQ0FBQyxDQUFDO3FCQUNELElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQy9DLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILFlBQVksQ0FBQyxTQUFtQixFQUFFLEtBQWE7UUFDN0MsU0FBUyxDQUFDLE1BQU0sR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxjQUFjLENBQUMsSUFBWTtRQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztRQUN4QixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFO1lBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUN4RCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsS0FBSyxDQUFDLGtCQUFrQixDQUFDLElBQVk7UUFDbkMsTUFBTSxVQUFVLEdBQXFCLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3RFLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDO2FBQzNDLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRTtZQUNsQyxNQUFNLFFBQVEsR0FBa0I7Z0JBQzlCLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQztnQkFDakQsR0FBRyxDQUFDLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQzthQUNsRSxDQUFDO1lBQ0YsT0FBTyxRQUFRLENBQUM7UUFDbEIsQ0FBQyxDQUFDO2FBQ0QsS0FBSyxDQUFDLENBQUMsS0FBb0IsRUFBRSxFQUFFO1lBQzlCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ25CLE9BQU8sSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdEMsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxNQUFNLENBQUMsT0FBc0IsSUFBSTtRQUMvQixJQUFJLE9BQXlCLENBQUM7UUFDOUIsSUFBSSxJQUFJO1lBQUUsT0FBTyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDOztZQUNoRCxPQUFPLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRTVELElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDO2FBQy9DLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRSxDQUFDO1lBQ25DLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQztZQUNqRCxHQUFHLENBQUMsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1NBQ2xFLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7O09BR0c7SUFDSCxlQUFlO1FBQ2IsTUFBTSxpQkFBaUIsR0FBNEI7WUFDakQsVUFBVSxFQUFFLEVBQUU7WUFDZCxJQUFJLEVBQUUsSUFBSSxDQUFDLFdBQVc7U0FDdkIsQ0FBQztRQUNGLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLHdCQUF3QixFQUFFO1lBQzNELEVBQUUsRUFBRSwwQkFBMEI7WUFDOUIsS0FBSyxFQUFFLE9BQU87WUFDZCxJQUFJLEVBQUUsaUJBQWlCO1NBQ3hCLENBQUMsQ0FBQztRQUNILFNBQVMsQ0FBQyxXQUFXLEVBQUU7YUFDcEIsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQ2IsT0FBTyxDQUFDLENBQUMsUUFBc0MsRUFBRSxFQUFFO1lBQ2xELElBQUksUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUN4QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBQzdCLEdBQUcsSUFBSSxDQUFDLFdBQVcsSUFBSSxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUM7Z0JBQ3JFLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDNUIsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLFdBQVcsQ0FBQyxLQUFnQjtRQUNoQyxJQUFJLENBQUMsS0FBSztZQUFFLE9BQU87UUFFbkIsd0NBQXdDO1FBQ3hDLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUM5RCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO1lBQ3pELE9BQU87UUFDVCxDQUFDO1FBRUQsTUFBTSxhQUFhLEdBQW1CLEVBQUUsQ0FBQztRQUN6QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ3RDLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0QixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsY0FBYztpQkFDaEMsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUM5QyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUM7aUJBQ2hELElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDaEQsS0FBSyxDQUFDLENBQUMsS0FBb0IsRUFBRSxFQUFFO2dCQUM5QixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2xELENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQztRQUVELElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTTtZQUFFLE9BQU87UUFFbEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDOUIsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksYUFBYSxDQUFDLE1BQU0sSUFBSSxhQUFhLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxhQUFhLENBQUMsQ0FBQztJQUNySCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxhQUFhLENBQUMsTUFBYTtRQUMvQixNQUFNLEtBQUssR0FBZ0MsTUFBTSxDQUFDLE1BQU8sQ0FBQyxLQUFpQixDQUFDO1FBQzVFLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxpQkFBaUIsQ0FBQyxLQUFvQixFQUFFLFFBQWdCO1FBQ3RELElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUNiLEtBQUssQ0FBQyxJQUFJLEtBQUssc0JBQXNCLENBQUMsQ0FBQztZQUNyQyxzQ0FBc0MsQ0FBQyxDQUFDO1lBQ3hDLDBCQUEwQixRQUFRLEdBQUcsRUFDdkMsS0FBSyxDQUNOLENBQUM7SUFDSixDQUFDOzhHQTFTVSxvQkFBb0I7a0dBQXBCLG9CQUFvQixvT0N0RGpDLHl5TUEwSUEsNnFERGxHSSxTQUFTLDZDQUNULGVBQWUsd1VBQ2YsYUFBYSxtTEFDYixjQUFjLDJsQ0FDZCxpQkFBaUIsOFdBQ2pCLHdCQUF3QiwrRkFDeEIsZUFBZSwrQ0FDZixRQUFRLDZDQUNSLDJCQUEyQiw2R0FDM0IscUJBQXFCLHdIQUNyQix1QkFBdUIscUZBQ3ZCLE9BQU87OzJGQUdFLG9CQUFvQjtrQkFwQmhDLFNBQVM7K0JBQ0UsbUJBQW1CLGNBR2pCLElBQUksV0FDUDt3QkFDUCxTQUFTO3dCQUNULGVBQWU7d0JBQ2YsYUFBYTt3QkFDYixjQUFjO3dCQUNkLGlCQUFpQjt3QkFDakIsd0JBQXdCO3dCQUN4QixlQUFlO3dCQUNmLFFBQVE7d0JBQ1IsMkJBQTJCO3dCQUMzQixxQkFBcUI7d0JBQ3JCLHVCQUF1Qjt3QkFDdkIsT0FBTztxQkFDUjtzSkF5QkQsU0FBUztzQkFEUixLQUFLO2dCQU9OLFlBQVk7c0JBRFgsS0FBSztnQkFPTixlQUFlO3NCQURkLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIGVmZmVjdCwgSW5wdXQsIE9uSW5pdCwgb3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGaXJlYmFzZVN0b3JhZ2VTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9maXJlYmFzZS1zdG9yYWdlLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3RvcmFnZVJlZmVyZW5jZSwgVXBsb2FkUmVzdWx0IH0gZnJvbSAnQGFuZ3VsYXIvZmlyZS9zdG9yYWdlJztcbmltcG9ydCB7IEZpcmViYXNlRXJyb3IgfSBmcm9tICdAYW5ndWxhci9maXJlL2FwcC9maXJlYmFzZSc7XG5pbXBvcnQgeyBNYXREaWFsb2cgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9kaWFsb2cnO1xuaW1wb3J0IHtcbiAgTmV3Rm9sZGVyRGlhbG9nQ2xvc2VDb250cmFjdCxcbiAgTmV3Rm9sZGVyRGlhbG9nQ29tcG9uZW50LCBOZXdGb2xkZXJEaWFsb2dDb250cmFjdCxcbn0gZnJvbSAnLi9jb21wb25lbnRzL25ldy1mb2xkZXItZGlhbG9nL25ldy1mb2xkZXItZGlhbG9nLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTdG9yYWdlSXRlbSwgU3RvcmFnZUZpbGUgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgU2VsZWN0aW9uTW9kZWwgfSBmcm9tICdAYW5ndWxhci9jZGsvY29sbGVjdGlvbnMnO1xuaW1wb3J0IHtcbiAgRGVsZXRlRmlsZXNEaWFsb2dDb21wb25lbnQsXG59IGZyb20gJy4vY29tcG9uZW50cy9kZWxldGUtZmlsZXMtZGlhbG9nL2RlbGV0ZS1maWxlcy1kaWFsb2cuY29tcG9uZW50JztcbmltcG9ydCB7IEFzeW5jUGlwZSwgRGF0ZVBpcGUsIE5nQ2xhc3MgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTWF0QnV0dG9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvYnV0dG9uJztcbmltcG9ydCB7IE1hdEljb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9pY29uJztcbmltcG9ydCB7IE1hdFRhYmxlTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvdGFibGUnO1xuaW1wb3J0IHsgTWF0Q2hlY2tib3hNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9jaGVja2JveCc7XG5pbXBvcnQge1xuICBTdG9yYWdlSXRlbUljb25Db21wb25lbnQsXG59IGZyb20gJy4vY29tcG9uZW50cy9zdG9yYWdlLWl0ZW0taWNvbi9zdG9yYWdlLWl0ZW0taWNvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgRm9ybWF0Qnl0ZXNQaXBlIH0gZnJvbSAnLi9waXBlcy9mb3JtYXQtYnl0ZXMucGlwZSc7XG5pbXBvcnQge1xuICBTdG9yYWdlRmlsZVByZXZpZXdDb21wb25lbnQsXG59IGZyb20gJy4vY29tcG9uZW50cy9zdG9yYWdlLWZpbGUtcHJldmlldy9zdG9yYWdlLWZpbGUtcHJldmlldy5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmlsZURyb3B6b25lRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL2ZpbGUtZHJvcHpvbmUuZGlyZWN0aXZlJztcbmltcG9ydCB7XG4gIExvYWRpbmdPckVycm9yQ29tcG9uZW50LFxufSBmcm9tICcuL2NvbXBvbmVudHMvbG9hZGluZy1vci1lcnJvci9sb2FkaW5nLW9yLWVycm9yLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb25zb2xlTG9nZ2VyU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvY29uc29sZS1sb2dnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdG9TaWduYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlL3J4anMtaW50ZXJvcCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Fub24tZmlsZS1tYW5hZ2VyJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2ZpbGUtbWFuYWdlci5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsOiAnLi9maWxlLW1hbmFnZXIuY29tcG9uZW50LnNjc3MnLFxuICBzdGFuZGFsb25lOiB0cnVlLFxuICBpbXBvcnRzOiBbXG4gICAgQXN5bmNQaXBlLFxuICAgIE1hdEJ1dHRvbk1vZHVsZSxcbiAgICBNYXRJY29uTW9kdWxlLFxuICAgIE1hdFRhYmxlTW9kdWxlLFxuICAgIE1hdENoZWNrYm94TW9kdWxlLFxuICAgIFN0b3JhZ2VJdGVtSWNvbkNvbXBvbmVudCxcbiAgICBGb3JtYXRCeXRlc1BpcGUsXG4gICAgRGF0ZVBpcGUsXG4gICAgU3RvcmFnZUZpbGVQcmV2aWV3Q29tcG9uZW50LFxuICAgIEZpbGVEcm9wem9uZURpcmVjdGl2ZSxcbiAgICBMb2FkaW5nT3JFcnJvckNvbXBvbmVudCxcbiAgICBOZ0NsYXNzLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBGaWxlTWFuYWdlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIC8qKlxuICAgKiBUaGUgY29sdW1ucyB0byBkaXNwbGF5IGluIHRoZSBmaWxlIG1hbmFnZW1lbnQgdGFibGUuXG4gICAqL1xuICB0YWJsZUNvbHVtbnM6IHN0cmluZ1tdID0gWydjaGVja2JveCcsICduYW1lJywgJ3NpemUnLCAndHlwZScsICdsYXN0TW9kaWZpZWQnXTtcbiAgLyoqXG4gICAqIEEgUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgU3RvcmFnZUl0ZW0gb2JqZWN0cyByZXByZXNlbnRpbmdcbiAgICogdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGNvbnRlbnRzLCBvciB1bmRlZmluZWQgaWYgYW4gZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgaXRlbXMkPzogUHJvbWlzZTxTdG9yYWdlSXRlbVtdPiB8IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHBhdGggd2l0aGluIHRoZSBzdG9yYWdlIHN5c3RlbS5cbiAgICovXG4gIGN1cnJlbnRQYXRoID0gJyc7XG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgcG90ZW50aWFsIEZpcmViYXNlRXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIGZpbGUgb3BlcmF0aW9ucy5cbiAgICovXG4gIGVycm9yPzogRmlyZWJhc2VFcnJvcjtcblxuICAvKipcbiAgICogVXNlZCBmb3IgbWFuYWdpbmcgbXVsdGlwbGUgaXRlbSBzZWxlY3Rpb24gd2l0aGluIHRoZSBmaWxlIG1hbmFnZXIuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uTW9kZWw8U3RvcmFnZUl0ZW0+KHRydWUsIFtdKTtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmaWxlIChpZiBhbnkpLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2VsZWN0ZWRGaWxlOiBTdG9yYWdlRmlsZSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIHJvb3QgcGF0aCB3aXRoaW4gdGhlIHN0b3JhZ2Ugc3lzdGVtIHdoZXJlIHRoZSBmaWxlIG1hbmFnZXIgb3BlcmF0ZXMuXG4gICAqL1xuICBASW5wdXQoKVxuICByb290U3RvcmFnZVBhdGggPSAnJztcblxuICBzZWxlY3Rpb25DaGFuZ2VTaWduYWwgPSB0b1NpZ25hbCh0aGlzLnNlbGVjdGlvbi5jaGFuZ2VkKTtcbiAgc2VsZWN0aW9uQ2hhbmdlID0gb3V0cHV0PFN0b3JhZ2VJdGVtW10gfCBudWxsPigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZGlhbG9nOiBNYXREaWFsb2csXG4gICAgcHJpdmF0ZSBjTG9nOiBDb25zb2xlTG9nZ2VyU2VydmljZSxcbiAgICBwcml2YXRlIHN0b3JhZ2VTZXJ2aWNlOiBGaXJlYmFzZVN0b3JhZ2VTZXJ2aWNlLFxuICApIHtcbiAgICBlZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5zZWxlY3Rpb25DaGFuZ2VTaWduYWwoKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQoc2VsZWN0aW9uQ2hhbmdlPy5zb3VyY2Uuc2VsZWN0ZWQgfHwgbnVsbCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICAvKiogU2V0cyB0aGUgaW5pdGlhbCBwYXRoIHdpdGhpbiB0aGUgc3RvcmFnZSBzeXN0ZW0gKi9cbiAgICB0aGlzLmN1cnJlbnRQYXRoID0gdGhpcy5yb290U3RvcmFnZVBhdGg7XG4gICAgLyoqIEZldGNoZXMgdGhlIGluaXRpYWwgc3RvcmFnZSBpdGVtcyAqL1xuICAgIHRoaXMuaXRlbXMkID0gdGhpcy5nZXRBbGxTdG9yYWdlSXRlbXModGhpcy5jdXJyZW50UGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogRG93bmxvYWRzIHRoZSBwcm92aWRlZCBmaWxlcyBieSB0cmlnZ2VyaW5nIGRvd25sb2FkIGxpbmtzLlxuICAgKiBAcGFyYW0ge1N0b3JhZ2VJdGVtW119IGZpbGVzIC0gVGhlIGZpbGVzIHRvIGRvd25sb2FkLlxuICAgKi9cbiAgYXN5bmMgZG93bmxvYWRGaWxlcyhmaWxlczogU3RvcmFnZUl0ZW1bXSkge1xuICAgIGF3YWl0IHRoaXMuc3RvcmFnZVNlcnZpY2Uub3BlbkFsbEZpbGVzKGZpbGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBzZWxlY3Rpb24gb2YgYWxsIGl0ZW1zIGluIHRoZSBmaWxlIGxpc3RpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tlZCAtIFdoZXRoZXIgdG8gc2VsZWN0IG9yIGRlc2VsZWN0IGFsbCBpdGVtcy5cbiAgICogQHBhcmFtIHtTdG9yYWdlSXRlbVtdfSBpdGVtcyAtIFRoZSBsaXN0IG9mIGZpbGUgaXRlbXMuXG4gICAqL1xuICB0b2dnbGVBbGxJdGVtcyhjaGVja2VkOiBib29sZWFuLCBpdGVtczogU3RvcmFnZUl0ZW1bXSkge1xuICAgIGlmICghY2hlY2tlZCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0KC4uLml0ZW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYWxsIGl0ZW1zIGluIHRoZSBmaWxlIGxpc3RpbmcgYXJlIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdG9yYWdlSXRlbVtdfSBpdGVtcyAtIFRoZSBsaXN0IG9mIGZpbGUgaXRlbXMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYWxsIGl0ZW1zIGFyZSBzZWxlY3RlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgYWxsSXRlbXNTZWxlY3RlZChpdGVtczogU3RvcmFnZUl0ZW1bXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5zZWxlY3RlZC5sZW5ndGggPT09IGl0ZW1zLmxlbmd0aCAmJlxuICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0ZWQubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgc29tZSwgYnV0IG5vdCBhbGwsIGl0ZW1zIGluIHRoZSBmaWxlIGxpc3RpbmcgYXJlIHNlbGVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0b3JhZ2VJdGVtW119IGl0ZW1zIC0gVGhlIGxpc3Qgb2YgZmlsZSBpdGVtcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIHN0YXRlIGlzIGluZGV0ZXJtaW5hdGUsIGZhbHNlXG4gICAqIG90aGVyd2lzZS5cbiAgICovXG4gIGFsbEl0ZW1zSW5kZXRlcm1pbmF0ZShpdGVtczogU3RvcmFnZUl0ZW1bXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5zZWxlY3RlZC5sZW5ndGggPiAwICYmXG4gICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RlZC5sZW5ndGggPCBpdGVtcy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3Igd2hlbiBhIHN0b3JhZ2UgaXRlbSBpcyBzZWxlY3RlZC4gVXBkYXRlcyB0aGUgbmF2aWdhdGlvblxuICAgKiBpZiBhIGZvbGRlciBpcyBzZWxlY3RlZCwgb3Igc2V0cyB0aGUgc2VsZWN0ZWQgZmlsZSBpZiBhIGZpbGUgaXMgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RvcmFnZUl0ZW19IGl0ZW0gLSBUaGUgc2VsZWN0ZWQgU3RvcmFnZUl0ZW0uXG4gICAqL1xuICBzdG9yYWdlSXRlbVNlbGVjdGVkKGl0ZW06IFN0b3JhZ2VJdGVtKSB7XG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2ZvbGRlcicpIHRoaXMuc2V0U3RvcmFnZVBhdGgoaXRlbS5mdWxsUGF0aCk7XG4gICAgZWxzZSBpZiAoaXRlbS50eXBlID09PSAnZmlsZScpIHRoaXMuc2VsZWN0ZWRGaWxlID0gaXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGluY2x1ZGVzIGF0IGxlYXN0IG9uZSBmb2xkZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSBmb2xkZXIgaXMgcGFydCBvZiB0aGUgc2VsZWN0aW9uLCBmYWxzZVxuICAgKiBvdGhlcndpc2UuXG4gICAqL1xuICBnZXQgc2VsZWN0aW9uSW5jbHVkZXNGb2xkZXIoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGVkLnNvbWUoKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gJ2ZvbGRlcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIGEgZGlhbG9nIHRvIGNvbmZpcm0gZGVsZXRpb24sIGFuZCBoYW5kbGVzIGRlbGV0aW5nIHNlbGVjdGVkIGl0ZW1zXG4gICAqIGlmIGNvbmZpcm1lZC4gQ2xlYXJzIHRoZSBzZWxlY3Rpb24gYW5kIHVwZGF0ZXMgdGhlIGZpbGUgbGlzdGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdG9yYWdlSXRlbVtdfSBpdGVtcyAtIFRoZSBpdGVtcyB0byBkZWxldGUuXG4gICAqL1xuICBkZWxldGVJdGVtcyhpdGVtczogU3RvcmFnZUl0ZW1bXSkge1xuICAgIGNvbnN0IGRpYWxvZ1JlZiA9IHRoaXMuZGlhbG9nLm9wZW4oRGVsZXRlRmlsZXNEaWFsb2dDb21wb25lbnQsIHtcbiAgICAgIGlkOiAnZGVsZXRlLWZpbGVzLWRpYWxvZycsXG4gICAgICBtaW5XaWR0aDogJzI1MHB4JyxcbiAgICB9KTtcbiAgICBkaWFsb2dSZWYuYWZ0ZXJDbG9zZWQoKS5waXBlKGZpcnN0KCkpLmZvckVhY2goKGNvbmZpcm06IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKGNvbmZpcm0pIHtcbiAgICAgICAgICB0aGlzLnN0b3JhZ2VTZXJ2aWNlLmRlbGV0ZUZpbGVzKGl0ZW1zKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgICAgICAgICBpZiAoaXRlbXMuc29tZSgoaXRlbSkgPT4gaXRlbSA9PSB0aGlzLnNlbGVjdGVkRmlsZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRmlsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMucmVsb2FkKHRoaXMuY3VycmVudFBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIGJyZWFkY3J1bWItc3R5bGUgcGF0aCBzdHJpbmcgYmFzZWQgb24gdGhlIGN1cnJlbnQgcGF0aFxuICAgKiBoaXN0b3J5LiBVc2VkIGZvciBuYXZpZ2F0aW9uIGRpc3BsYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhBcnJheSAtIEFuIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB1cCB0byB3aGljaCBwYXRoIHNlZ21lbnRzIHNob3VsZCBiZVxuICAgKiBpbmNsdWRlZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29uc3RydWN0ZWQgcGF0aCBzdHJpbmcuXG4gICAqL1xuICBnZXRDcnVtYlBhdGgocGF0aEFycmF5OiBzdHJpbmdbXSwgaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcGF0aEFycmF5Lmxlbmd0aCA9IGluZGV4ICsgMTtcbiAgICByZXR1cm4gcGF0aEFycmF5LmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IHBhdGggYW5kIGZldGNoZXMgdGhlIG5ldyBmaWxlIGxpc3RpbmcuXG4gICAqIENsZWFycyBhbnkgZXhpc3Rpbmcgc2VsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBuZXcgc3RvcmFnZSBwYXRoLlxuICAgKi9cbiAgc2V0U3RvcmFnZVBhdGgocGF0aDogc3RyaW5nKSB7XG4gICAgdGhpcy5pdGVtcyQgPSB0aGlzLmdldEFsbFN0b3JhZ2VJdGVtcyhwYXRoKTtcbiAgICB0aGlzLmN1cnJlbnRQYXRoID0gcGF0aDtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb24uaGFzVmFsdWUoKSkgdGhpcy5zZWxlY3Rpb24uY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYW5kIHByb2Nlc3NlcyBhbGwgaXRlbXMgd2l0aGluIGEgZ2l2ZW4gc3RvcmFnZSBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBzdG9yYWdlIHBhdGggdG8gbGlzdC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxTdG9yYWdlSXRlbVtdPn0gQSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgaXRlbXMsXG4gICAqIG9yIHVuZGVmaW5lZCBpbiBjYXNlIG9mIGVycm9yLlxuICAgKi9cbiAgYXN5bmMgZ2V0QWxsU3RvcmFnZUl0ZW1zKHBhdGg6IHN0cmluZyk6IFByb21pc2U8U3RvcmFnZUl0ZW1bXT4ge1xuICAgIGNvbnN0IHN0b3JhZ2VSZWY6IFN0b3JhZ2VSZWZlcmVuY2UgPSB0aGlzLnN0b3JhZ2VTZXJ2aWNlLmdldFJlZihwYXRoKTtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlU2VydmljZS5saXN0QWxsKHN0b3JhZ2VSZWYpXG4gICAgICAudGhlbihhc3luYyAoeyBpdGVtcywgcHJlZml4ZXMgfSkgPT4ge1xuICAgICAgICBjb25zdCBhbGxJdGVtczogU3RvcmFnZUl0ZW1bXSA9IFtcbiAgICAgICAgICAuLi5wcmVmaXhlcy5tYXAodGhpcy5zdG9yYWdlU2VydmljZS5pbXBvcnRGb2xkZXIpLFxuICAgICAgICAgIC4uLihhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAodGhpcy5zdG9yYWdlU2VydmljZS5pbXBvcnRGaWxlKSkpLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gYWxsSXRlbXM7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcjogRmlyZWJhc2VFcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVsb2FkcyB0aGUgZmlsZSBhbmQgZm9sZGVyIGxpc3Rpbmcgd2l0aGluIHRoZSBjdXJyZW50IG9yIHNwZWNpZmllZCBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHBhdGggLSBPcHRpb25hbC4gVGhlIHBhdGggdG8gcmVsb2FkLiBJZiBudWxsLFxuICAgKiB0aGUgY3VycmVudCBwYXRoIGlzIHVzZWQuXG4gICAqL1xuICByZWxvYWQocGF0aDogc3RyaW5nIHwgbnVsbCA9IG51bGwpIHtcbiAgICBsZXQgcGF0aFJlZjogU3RvcmFnZVJlZmVyZW5jZTtcbiAgICBpZiAocGF0aCkgcGF0aFJlZiA9IHRoaXMuc3RvcmFnZVNlcnZpY2UuZ2V0UmVmKHBhdGgpO1xuICAgIGVsc2UgcGF0aFJlZiA9IHRoaXMuc3RvcmFnZVNlcnZpY2UuZ2V0UmVmKHRoaXMuY3VycmVudFBhdGgpO1xuXG4gICAgdGhpcy5pdGVtcyQgPSB0aGlzLnN0b3JhZ2VTZXJ2aWNlLmxpc3RBbGwocGF0aFJlZilcbiAgICAgIC50aGVuKGFzeW5jICh7IGl0ZW1zLCBwcmVmaXhlcyB9KSA9PiBbXG4gICAgICAgIC4uLnByZWZpeGVzLm1hcCh0aGlzLnN0b3JhZ2VTZXJ2aWNlLmltcG9ydEZvbGRlciksXG4gICAgICAgIC4uLihhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAodGhpcy5zdG9yYWdlU2VydmljZS5pbXBvcnRGaWxlKSkpLFxuICAgICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgYSBkaWFsb2cgdG8gY3JlYXRlIGEgbmV3IGZvbGRlciBhbmQgdXBkYXRlcyBmb2xkZXIgbGlzdGluZ1xuICAgKiBpZiBzdWNjZXNzZnVsLlxuICAgKi9cbiAgY3JlYXRlTmV3Rm9sZGVyKCkge1xuICAgIGNvbnN0IG5ld0ZvbGRlckNvbnRyYWN0OiBOZXdGb2xkZXJEaWFsb2dDb250cmFjdCA9IHtcbiAgICAgIGZvbGRlck5hbWU6ICcnLFxuICAgICAgcGF0aDogdGhpcy5jdXJyZW50UGF0aCxcbiAgICB9O1xuICAgIGNvbnN0IGRpYWxvZ1JlZiA9IHRoaXMuZGlhbG9nLm9wZW4oTmV3Rm9sZGVyRGlhbG9nQ29tcG9uZW50LCB7XG4gICAgICBpZDogJ2NyZWF0ZS1uZXctZm9sZGVyLWRpYWxvZycsXG4gICAgICB3aWR0aDogJzI1MHB4JyxcbiAgICAgIGRhdGE6IG5ld0ZvbGRlckNvbnRyYWN0LFxuICAgIH0pO1xuICAgIGRpYWxvZ1JlZi5hZnRlckNsb3NlZCgpXG4gICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgLmZvckVhY2goKGNvbnRyYWN0OiBOZXdGb2xkZXJEaWFsb2dDbG9zZUNvbnRyYWN0KSA9PiB7XG4gICAgICAgIGlmIChjb250cmFjdC5mb2xkZXJOYW1lKSB7XG4gICAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuY3VycmVudFBhdGggP1xuICAgICAgICAgICAgYCR7dGhpcy5jdXJyZW50UGF0aH0vJHtjb250cmFjdC5mb2xkZXJOYW1lfWAgOiBjb250cmFjdC5mb2xkZXJOYW1lO1xuICAgICAgICAgIHRoaXMuc2V0U3RvcmFnZVBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZmlsZSB1cGxvYWQgbG9naWMsIGluY2x1ZGluZyB2YWxpZGF0aW9uIGFuZCB1cGRhdGluZyB0aGVcbiAgICogZmlsZSBsaXN0aW5nIHVwb24gc3VjY2Vzc2Z1bCB1cGxvYWQuIExvZ3MgZXJyb3JzIGlmIGVuY291bnRlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZpbGVMaXN0fSBmaWxlcyAtIEFuIG9wdGlvbmFsIEZpbGVMaXN0IG9mIGZpbGVzIHRvIHVwbG9hZC5cbiAgICovXG4gIGFzeW5jIHVwbG9hZEl0ZW1zKGZpbGVzPzogRmlsZUxpc3QpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIWZpbGVzKSByZXR1cm47XG5cbiAgICAvLyBwcmV2ZW50IGZpbGUgbmFtZXMgdG8gaGF2ZSBcIixcIihjb21tYSlcbiAgICBpZiAoQXJyYXkuZnJvbShmaWxlcykuc29tZSgoZmlsZSkgPT4gZmlsZS5uYW1lLmluY2x1ZGVzKCcsJykpKSB7XG4gICAgICB0aGlzLmNMb2cud2FybihgRmlsZSBuYW1lcyBjYW5ub3QgaW5jbHVkZSBhIFwiLFwiKGNvbW1hKWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHVwbG9hZGVkRmlsZXM6IFVwbG9hZFJlc3VsdFtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmlsZSA9IGZpbGVzW2ldO1xuICAgICAgY29uc3QgZmlsZVJlZiA9IHRoaXMuc3RvcmFnZVNlcnZpY2VcbiAgICAgICAgLmdldFJlZihgJHt0aGlzLmN1cnJlbnRQYXRofS8ke2ZpbGUubmFtZX1gKTtcbiAgICAgIGF3YWl0IHRoaXMuc3RvcmFnZVNlcnZpY2UudXBsb2FkRmlsZShmaWxlUmVmLCBmaWxlKVxuICAgICAgICAudGhlbigoc25hcHNob3QpID0+IHVwbG9hZGVkRmlsZXMucHVzaChzbmFwc2hvdCkpXG4gICAgICAgIC5jYXRjaCgoZXJyb3I6IEZpcmViYXNlRXJyb3IpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVVcGxvYWRFcnJvcihlcnJvciwgZmlsZS5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF1cGxvYWRlZEZpbGVzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgdGhpcy5yZWxvYWQodGhpcy5jdXJyZW50UGF0aCk7XG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW4gKi9cbiAgICB0aGlzLmNMb2cuaW5mbyhgVXBsb2FkZWQgJHt1cGxvYWRlZEZpbGVzLmxlbmd0aH0gJHt1cGxvYWRlZEZpbGVzLmxlbmd0aCA9PT0gMSA/ICdmaWxlJyA6ICdmaWxlcyd9YCwgdXBsb2FkZWRGaWxlcyk7XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgZmlsZSBpbnB1dCBjaGFuZ2UuIFRyaWdnZXJzIHRoZSB1cGxvYWQgcHJvY2Vzcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gJGV2ZW50IC0gVGhlIGZpbGUgaW5wdXQgY2hhbmdlIGV2ZW50LlxuICAgKi9cbiAgYXN5bmMgb25GaWxlc1NlbGVjdCgkZXZlbnQ6IEV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZmlsZXM6IEZpbGVMaXN0ID0gKDxIVE1MSW5wdXRFbGVtZW50PiRldmVudC50YXJnZXQpLmZpbGVzIGFzIEZpbGVMaXN0O1xuICAgIGF3YWl0IHRoaXMudXBsb2FkSXRlbXMoZmlsZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgbG9nZ2luZyBvZiBlcnJvcnMgZHVyaW5nIHRoZSBmaWxlIHVwbG9hZCBwcm9jZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZpcmViYXNlRXJyb3J9IGVycm9yIC0gVGhlIEZpcmViYXNlIGVycm9yIG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpbGUgdGhhdCBmYWlsZWQgdG8gdXBsb2FkLlxuICAgKi9cbiAgaGFuZGxlVXBsb2FkRXJyb3IoZXJyb3I6IEZpcmViYXNlRXJyb3IsIGZpbGVuYW1lOiBzdHJpbmcpIHtcbiAgICB0aGlzLmNMb2cuZXJyb3IoXG4gICAgICBlcnJvci5jb2RlID09PSAnc3RvcmFnZS91bmF1dGhvcml6ZWQnID9cbiAgICAgICAgJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHVwbG9hZCcgOlxuICAgICAgICBgRXJyb3IgdXBsb2FkaW5nIGZpbGU6ICcke2ZpbGVuYW1lfSdgLFxuICAgICAgZXJyb3IsXG4gICAgKTtcbiAgfVxufVxuIiwiQGlmIChpdGVtcyQgfCBhc3luYzsgYXMgaXRlbXMpIHtcbiAgPGRpdiBjbGFzcz1cImNhcmRcIj5cbiAgICA8aW5wdXQgI2lucHV0VXBsb2FkIG11bHRpcGxlIGNsYXNzPVwiaW5wdXRVcGxvYWRcIlxuICAgICAgICAgICB0eXBlPVwiZmlsZVwiIGF1dG9jb21wbGV0ZT1cIm9mZlwiIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAoY2hhbmdlKT1cIm9uRmlsZXNTZWxlY3QoJGV2ZW50KVwiIC8+XG4gICAgPCEtLSBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L3RlbXBsYXRlL25vLWNhbGwtZXhwcmVzc2lvbiAtLT5cbiAgICBAaWYgKHNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgIDxoZWFkZXIgY2xhc3M9XCJoZWFkZXJcIj5cbiAgICAgICAgPCEtLSBDcnVtYnMgLS0+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiY3J1bWJzXCI+XG4gICAgICAgICAgPGJ1dHRvbiBtYXQtaWNvbi1idXR0b24gdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiY3VycmVudFBhdGg9PT1yb290U3RvcmFnZVBhdGhcIlxuICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInNldFN0b3JhZ2VQYXRoKHJvb3RTdG9yYWdlUGF0aClcIj5cbiAgICAgICAgICAgIDxtYXQtaWNvbiBmb250SWNvbj1cImhvbWVcIiAvPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwhLS0gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC90ZW1wbGF0ZS9uby1jYWxsLWV4cHJlc3Npb24gLS0+XG4gICAgICAgICAgQGZvciAoY3J1bWIgb2YgY3VycmVudFBhdGguc3BsaXQoJy8nKTsgdHJhY2sgY3J1bWI7bGV0IGk9JGluZGV4OyBsZXQgbGFzdD0kbGFzdCkge1xuICAgICAgICAgICAgQGlmIChjcnVtYiAhPT0gcm9vdFN0b3JhZ2VQYXRoKSB7XG4gICAgICAgICAgICAgIEBpZiAoY3VycmVudFBhdGghPT1yb290U3RvcmFnZVBhdGgpIHtcbiAgICAgICAgICAgICAgICA8bWF0LWljb24gY2xhc3M9XCJvdmVyZmxvdy12aXNpYmxlXCIgZm9udEljb249XCJjaGV2cm9uX3JpZ2h0XCIgLz5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA8YnV0dG9uIG1hdC1idXR0b24gdHlwZT1cImJ1dHRvblwiIFtkaXNhYmxlZF09XCJsYXN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwic2V0U3RvcmFnZVBhdGgoZ2V0Q3J1bWJQYXRoKGN1cnJlbnRQYXRoLnNwbGl0KCcvJyksIGkpKVwiPlxuICAgICAgICAgICAgICB7e2NydW1ifX1cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgIDxidXR0b24gbWF0LWljb24tYnV0dG9uIHR5cGU9XCJidXR0b25cIiAoY2xpY2spPVwicmVsb2FkKClcIj5cbiAgICAgICAgICA8bWF0LWljb24gZm9udEljb249XCJyZWZyZXNoXCIgLz5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gbWF0LWljb24tYnV0dG9uIHR5cGU9XCJidXR0b25cIiAoY2xpY2spPVwiY3JlYXRlTmV3Rm9sZGVyKClcIj5cbiAgICAgICAgICA8bWF0LWljb24gZm9udEljb249XCJjcmVhdGVfbmV3X2ZvbGRlclwiIC8+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxidXR0b24gbWF0LWZsYXQtYnV0dG9uIHR5cGU9XCJidXR0b25cIiBjb2xvcj1cInByaW1hcnlcIlxuICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImlucHV0VXBsb2FkLmNsaWNrKClcIj5VcGxvYWQ8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2hlYWRlcj5cbiAgICB9IEBlbHNlIHtcbiAgICAgIDxoZWFkZXIgY2xhc3M9XCJoZWFkZXIgaXRlbXMtc2VsZWN0ZWRcIj5cbiAgICAgICAgPGJ1dHRvbiBtYXQtaWNvbi1idXR0b24gdHlwZT1cImJ1dHRvblwiIChjbGljayk9XCJzZWxlY3Rpb24uY2xlYXIoKVwiPlxuICAgICAgICAgIDxtYXQtaWNvbiBmb250SWNvbj1cImNsb3NlXCIgLz5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxzcGFuPnt7c2VsZWN0aW9uLnNlbGVjdGVkLmxlbmd0aH19IHt7c2VsZWN0aW9uLnNlbGVjdGVkLmxlbmd0aCA9PT0gMSA/ICdpdGVtJyA6ICdpdGVtcyd9fTwvc3Bhbj5cbiAgICAgICAgPCEtLSBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L3RlbXBsYXRlL25vLWNhbGwtZXhwcmVzc2lvbiAtLT5cbiAgICAgICAgPGJ1dHRvbiBtYXQtcmFpc2VkLWJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY29sb3I9XCJhY2NlbnRcIiBbZGlzYWJsZWRdPVwic2VsZWN0aW9uSW5jbHVkZXNGb2xkZXJcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJkb3dubG9hZEZpbGVzKHNlbGVjdGlvbi5zZWxlY3RlZClcIj5Eb3dubG9hZCBmaWxlczwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIG1hdC1zdHJva2VkLWJ1dHRvbiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwiZGVsZXRlSXRlbXMoc2VsZWN0aW9uLnNlbGVjdGVkKVwiPkRlbGV0ZTwvYnV0dG9uPlxuICAgICAgPC9oZWFkZXI+XG4gICAgfVxuXG4gICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJ0YWJsZS1zaWRlYmFyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJsZS13cmFwcGVyXCIgW25nQ2xhc3NdPVwieydncmlkLWNvbHVtbi1lbmQtc3Bhbi04Jzogc2VsZWN0ZWRGaWxlfVwiPlxuICAgICAgICAgIDx0YWJsZSBtYXQtdGFibGUgW2RhdGFTb3VyY2VdPVwiaXRlbXNcIj5cbiAgICAgICAgICAgIDwhLS0gQ2hlY2tib3ggQ29sdW1uIC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBtYXRDb2x1bW5EZWY9XCJjaGVja2JveFwiPlxuICAgICAgICAgICAgICA8dGggKm1hdEhlYWRlckNlbGxEZWYgbWF0LWhlYWRlci1jZWxsIGNsYXNzPVwiY2hlY2tib3gtY29sdW1uXCI+XG4gICAgICAgICAgICAgICAgPCEtLSBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L3RlbXBsYXRlL25vLWNhbGwtZXhwcmVzc2lvbiAtLT5cbiAgICAgICAgICAgICAgICA8bWF0LWNoZWNrYm94IG5hbWU9XCJzZWxlY3QtYWxsXCIgW2NoZWNrZWRdPVwiYWxsSXRlbXNTZWxlY3RlZChpdGVtcylcIiBbaW5kZXRlcm1pbmF0ZV09XCJhbGxJdGVtc0luZGV0ZXJtaW5hdGUoaXRlbXMpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJpdGVtcy5sZW5ndGggPT09IDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNoYW5nZSk9XCJ0b2dnbGVBbGxJdGVtcygkZXZlbnQuY2hlY2tlZCwgaXRlbXMpXCIgLz5cbiAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgICAgPHRkICptYXRDZWxsRGVmPVwibGV0IGl0ZW1cIiBtYXQtY2VsbCBjbGFzcz1cImNoZWNrYm94LWNvbHVtblwiPlxuICAgICAgICAgICAgICAgIDwhLS0gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC90ZW1wbGF0ZS9uby1jYWxsLWV4cHJlc3Npb24gLS0+XG4gICAgICAgICAgICAgICAgPG1hdC1jaGVja2JveCBbY2hlY2tlZF09XCJzZWxlY3Rpb24uaXNTZWxlY3RlZChpdGVtKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwiJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGFuZ2UpPVwic2VsZWN0aW9uLnRvZ2dsZShpdGVtKVwiIC8+XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgPCEtLSBOYW1lIENvbHVtbiAtLT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgbWF0Q29sdW1uRGVmPVwibmFtZVwiPlxuICAgICAgICAgICAgICA8dGggKm1hdEhlYWRlckNlbGxEZWYgbWF0LWhlYWRlci1jZWxsPiBOYW1lIDwvdGg+XG4gICAgICAgICAgICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBpdGVtXCIgbWF0LWNlbGwgY2xhc3M9XCJuYW1lLWNvbHVtblwiPlxuICAgICAgICAgICAgICAgIDxhbm9uLXN0b3JhZ2UtaXRlbS1pY29uIFt0eXBlXT1cIml0ZW0udHlwZVwiIFtjb250ZW50VHlwZV09XCJpdGVtLmNvbnRlbnRUeXBlXCIgLz5cbiAgICAgICAgICAgICAgICA8c3Bhbj57e2l0ZW0ubmFtZX19PC9zcGFuPlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgICAgIDwhLS0gU2l6ZSBDb2x1bW4gLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj1cInNpemVcIj5cbiAgICAgICAgICAgICAgPHRoICptYXRIZWFkZXJDZWxsRGVmIG1hdC1oZWFkZXItY2VsbD4gU2l6ZSA8L3RoPlxuICAgICAgICAgICAgICA8dGQgKm1hdENlbGxEZWY9XCJsZXQgaXRlbVwiIG1hdC1jZWxsPlxuICAgICAgICAgICAgICAgIHt7aXRlbS50eXBlID09PSAnZm9sZGVyJyA/ICcmbWRhc2g7JyA6IGl0ZW0uc2l6ZSB8IGZvcm1hdEJ5dGVzfX1cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgICAgICA8IS0tIFR5cGUgQ29sdW1uIC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBtYXRDb2x1bW5EZWY9XCJ0eXBlXCI+XG4gICAgICAgICAgICAgIDx0aCAqbWF0SGVhZGVyQ2VsbERlZiBtYXQtaGVhZGVyLWNlbGw+IFR5cGUgPC90aD5cbiAgICAgICAgICAgICAgPHRkICptYXRDZWxsRGVmPVwibGV0IGl0ZW1cIiBtYXQtY2VsbD5cbiAgICAgICAgICAgICAgICB7e2l0ZW0udHlwZSA9PT0gJ2ZvbGRlcicgPyAnRm9sZGVyJyA6IGl0ZW0uY29udGVudFR5cGV9fVxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgICAgIDwhLS0gTGFzdCBNb2RpZmllZCBDb2x1bW4gLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj1cImxhc3RNb2RpZmllZFwiPlxuICAgICAgICAgICAgICA8dGggKm1hdEhlYWRlckNlbGxEZWYgbWF0LWhlYWRlci1jZWxsPiBMYXN0IE1vZGlmaWVkIDwvdGg+XG4gICAgICAgICAgICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBpdGVtXCIgbWF0LWNlbGw+XG4gICAgICAgICAgICAgICAge3tpdGVtLnR5cGUgPT09ICdmb2xkZXInID8gJyZtZGFzaDsnIDogaXRlbS51cGRhdGVkIHwgZGF0ZX19XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgPHRyICptYXRIZWFkZXJSb3dEZWY9XCJ0YWJsZUNvbHVtbnM7IHN0aWNreTogdHJ1ZVwiIG1hdC1oZWFkZXItcm93PjwvdHI+XG4gICAgICAgICAgICA8dHIgKm1hdFJvd0RlZj1cImxldCBpdGVtOyBjb2x1bW5zOiB0YWJsZUNvbHVtbnM7XCIgbWF0LXJvd1xuICAgICAgICAgICAgICAgIFtjbGFzcy5zZWxlY3RlZF09XCJzZWxlY3RlZEZpbGUgPT09IGl0ZW1cIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJzdG9yYWdlSXRlbVNlbGVjdGVkKGl0ZW0pXCI+PC90cj5cblxuICAgICAgICAgICAgPHRyICptYXROb0RhdGFSb3cgY2xhc3M9XCJtYXQtcm93XCI+XG4gICAgICAgICAgICAgIDx0ZCBjbGFzcz1cIm1hdC1jZWxsXCIgW2F0dHIuY29sc3Bhbl09XCJ0YWJsZUNvbHVtbnMubGVuZ3RoXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBhbm9uRmlsZURyb3B6b25lIGNsYXNzPVwiZW1wdHktZm9sZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgIGhvdmVyQ2xhc3M9XCJob3ZlcmluZ1wiIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwiaW5wdXRVcGxvYWQuY2xpY2soKVwiXG4gICAgICAgICAgICAgICAgICAgICAoa2V5dXApPVwiaW5wdXRVcGxvYWQuY2xpY2soKVwiXG4gICAgICAgICAgICAgICAgICAgICAoZHJvcHBlZCk9XCJ1cGxvYWRJdGVtcygkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2Pk5vIGZpbGVzIGZvdW5kPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8ZGl2PkRyYWcgYW5kIGRyb3AgZmlsZXMgdG8gdXBsb2FkPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIEBpZiAoc2VsZWN0ZWRGaWxlKSB7XG4gICAgICAgICAgPGFzaWRlIGNsYXNzPVwic2lkZWJhciBncmlkLWNvbHVtbi1lbmQtc3Bhbi00XCI+XG4gICAgICAgICAgICA8YW5vbi1zdG9yYWdlLWZpbGUtcHJldmlldyBbaXRlbV09XCJzZWxlY3RlZEZpbGVcIiAoX2Nsb3NlKT1cInNlbGVjdGVkRmlsZSA9IHVuZGVmaW5lZFwiIC8+XG4gICAgICAgICAgPC9hc2lkZT5cbiAgICAgICAgfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxufSBAZWxzZSB7XG4gIDxhbm9uLWxvYWRpbmctb3ItZXJyb3IgW2Vycm9yXT1cImVycm9yXCIgLz5cbn1cbiJdfQ==